"use strict";(self.webpackChunkdocumentacion=self.webpackChunkdocumentacion||[]).push([[2464],{5680:(e,a,n)=>{n.d(a,{xA:()=>c,yg:()=>g});var o=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function s(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?s(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,o,r=function(e,a){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var t=o.createContext({}),d=function(e){var a=o.useContext(t),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},c=function(e){var a=d(e.components);return o.createElement(t.Provider,{value:a},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},m=o.forwardRef((function(e,a){var n=e.components,r=e.mdxType,s=e.originalType,t=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),m=r,g=u["".concat(t,".").concat(m)]||u[m]||p[m]||s;return n?o.createElement(g,i(i({ref:a},c),{},{components:n})):o.createElement(g,i({ref:a},c))}));function g(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var l={};for(var t in a)hasOwnProperty.call(a,t)&&(l[t]=a[t]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<s;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7015:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>t,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var o=n(8168),r=(n(6540),n(5680));const s={sidebar_position:11},i='Conceptos de "C#" - Parte 6',l={unversionedId:"C--/guiaC6",id:"C--/guiaC6",title:'Conceptos de "C#" - Parte 6',description:'" - Parte 6',source:"@site/docs/C--/guiaC6.md",sourceDirName:"C--",slug:"/C--/guiaC6",permalink:"/documentacion/docs/C--/guiaC6",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/C--/guiaC6.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"C",previous:{title:'Conceptos de "C#" - Parte 5',permalink:"/documentacion/docs/C--/guiaC5"},next:{title:"API con .NET Core",permalink:"/documentacion/docs/C--/API"}},t={},d=[{value:"Palabra clave virtual",id:"palabra-clave-virtual",level:2},{value:"\xbfPor qu\xe9 usar virtual?",id:"por-qu\xe9-usar-virtual",level:4},{value:"C\xf3mo funciona virtual",id:"c\xf3mo-funciona-virtual",level:4},{value:"Minimal API",id:"minimal-api",level:2},{value:"Ventajas de las Minimal APIs",id:"ventajas-de-las-minimal-apis",level:4},{value:"Diferencias con los Controladores",id:"diferencias-con-los-controladores",level:4},{value:"Ejemplo de Minimal API",id:"ejemplo-de-minimal-api",level:4},{value:"Subconjuntos/rangos",id:"subconjuntosrangos",level:2},{value:"Caracter\xedsticas Clave de los Rangos y Subconjuntos",id:"caracter\xedsticas-clave-de-los-rangos-y-subconjuntos",level:4},{value:"C\xf3mo Trabajar con Rangos e \xcdndices",id:"c\xf3mo-trabajar-con-rangos-e-\xedndices",level:4},{value:"Uso de \xcdndices desde el Final",id:"uso-de-\xedndices-desde-el-final",level:4},{value:"Combinar \xcdndices y Rangos",id:"combinar-\xedndices-y-rangos",level:4},{value:"Desestructuraci\xf3n",id:"desestructuraci\xf3n",level:2},{value:"\xbfC\xf3mo Funciona la Desestructuraci\xf3n?",id:"c\xf3mo-funciona-la-desestructuraci\xf3n",level:4},{value:"Desestructuraci\xf3n de Tuplas",id:"desestructuraci\xf3n-de-tuplas",level:4},{value:"Desestructuraci\xf3n en Records",id:"desestructuraci\xf3n-en-records",level:4},{value:"Desestructuraci\xf3n con Clases Personalizadas",id:"desestructuraci\xf3n-con-clases-personalizadas",level:4},{value:"ReadOnlySpan&lt;T&gt;",id:"readonlyspant",level:2},{value:"\xbfQu\xe9 es ReadOnlySpan&lt;T&gt;?",id:"qu\xe9-es-readonlyspant",level:4},{value:"Caracter\xedsticas principales",id:"caracter\xedsticas-principales",level:4},{value:"Ejemplo",id:"ejemplo",level:4},{value:"expression-bodied member",id:"expression-bodied-member",level:2},{value:"M\xe9todos",id:"m\xe9todos",level:4},{value:"Propiedades",id:"propiedades",level:4},{value:"Operadores",id:"operadores",level:4},{value:"Constructores",id:"constructores",level:4},{value:"Span&lt;T&gt;",id:"spant",level:2},{value:"Caracter\xedsticas clave de Span&lt;T&gt;",id:"caracter\xedsticas-clave-de-spant",level:4},{value:"Ejemplo b\xe1sico de Span&lt;T&gt;",id:"ejemplo-b\xe1sico-de-spant",level:4},{value:"Span&lt;T&gt; vs ReadOnlySpan&lt;T&gt;",id:"spant-vs-readonlyspant",level:4},{value:"Diferencias principales",id:"diferencias-principales",level:5},{value:"Operadores sobrecargados",id:"operadores-sobrecargados",level:2},{value:"\xbfC\xf3mo se crea un operador sobrecargado?",id:"c\xf3mo-se-crea-un-operador-sobrecargado",level:4},{value:"Operadores que se pueden sobrecargar",id:"operadores-que-se-pueden-sobrecargar",level:4},{value:"Restricciones",id:"restricciones",level:4},{value:"Ejemplo de sobrecarga de operadores",id:"ejemplo-de-sobrecarga-de-operadores",level:4}],c={toc:d},u="wrapper";function p(e){let{components:a,...n}=e;return(0,r.yg)(u,(0,o.A)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"conceptos-de-c---parte-6"},'Conceptos de "C#" - Parte 6'),(0,r.yg)("h2",{id:"palabra-clave-virtual"},"Palabra clave virtual"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"La palabra clave virtual en C# se utiliza para permitir que un m\xe9todo, propiedad, \xedndice o evento en una clase base pueda ser anulado (sobrescrito) en una clase derivada. Esto es parte del mecanismo de polimorfismo en la programaci\xf3n orientada a objetos y permite que una clase derivada proporcione una implementaci\xf3n espec\xedfica de un m\xe9todo que ya est\xe1 definido en su clase base.")),(0,r.yg)("h4",{id:"por-qu\xe9-usar-virtual"},"\xbfPor qu\xe9 usar virtual?"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Flexibilidad: Permite que las clases derivadas personalicen el comportamiento de los m\xe9todos de la clase base. Esto es especialmente \xfatil cuando deseas que las subclases se comporten de manera diferente sin cambiar la implementaci\xf3n de la clase base."),(0,r.yg)("li",{parentName:"ul"},"Polimorfismo: La palabra clave virtual es esencial para el polimorfismo, ya que permite que se invoquen m\xe9todos de las clases derivadas a trav\xe9s de referencias de la clase base.")),(0,r.yg)("h4",{id:"c\xf3mo-funciona-virtual"},"C\xf3mo funciona virtual"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Cuando declaras un m\xe9todo como virtual en una clase base, cualquier clase que herede de esa clase puede anular (sobrescribir) ese m\xe9todo usando la palabra clave override. Esto significa que puedes cambiar el comportamiento del m\xe9todo en la clase derivada."),(0,r.yg)("li",{parentName:"ul"},"Aqu\xed hay un ejemplo que ilustra c\xf3mo se utiliza la palabra clave virtual:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Animal\n{\n    public virtual void HacerSonido()\n    {\n        Console.WriteLine("El animal hace un sonido.");\n    }\n}\n\npublic class Perro : Animal\n{\n    public override void HacerSonido()\n    {\n        Console.WriteLine("El perro ladra.");\n    }\n}\n\npublic class Gato : Animal\n{\n    public override void HacerSonido()\n    {\n        Console.WriteLine("El gato maulla.");\n    }\n}\n\nclass Programa\n{\n    static void Main()\n    {\n        Animal miAnimal;\n\n        miAnimal = new Perro();\n        miAnimal.HacerSonido(); // Imprime "El perro ladra."\n\n        miAnimal = new Gato();\n        miAnimal.HacerSonido(); // Imprime "El gato maulla."\n    }\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Detalles del ejemplo")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Clase Base: La clase Animal tiene un m\xe9todo HacerSonido() marcado como virtual. Esto significa que cualquier clase que herede de Animal puede anular(sobrescribir) este m\xe9todo."),(0,r.yg)("li",{parentName:"ul"},"Clases Derivadas: Las clases Perro y Gato heredan de Animal y anulan (sobrescriben) el m\xe9todo HacerSonido() con la palabra clave override, proporcionando su propia implementaci\xf3n."),(0,r.yg)("li",{parentName:"ul"},"Uso en el Programa Principal: En el m\xe9todo Main, se declara una variable de tipo Animal, pero se le asignan instancias de Perro y Gato. Cuando se llama a HacerSonido(), se invoca la implementaci\xf3n correcta del m\xe9todo en funci\xf3n del tipo real del objeto (Perro o Gato), demostrando el concepto de polimorfismo.")))),(0,r.yg)("h2",{id:"minimal-api"},"Minimal API"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Las Minimal APIs en C# son una forma simplificada de construir APIs utilizando ASP.NET Core. Se introdujeron en .NET 6 y permiten crear aplicaciones HTTP de manera m\xe1s ligera y menos estructurada que el enfoque tradicional basado en controladores. "),(0,r.yg)("li",{parentName:"ul"},"Las Minimal APIs permiten construir aplicaciones HTTP sin la necesidad de crear un controlador y una clase de configuraci\xf3n separada. En su lugar, puedes definir endpoints de manera directa en el archivo de inicio de tu aplicaci\xf3n, lo que resulta en menos c\xf3digo y una sintaxis m\xe1s concisa.")),(0,r.yg)("h4",{id:"ventajas-de-las-minimal-apis"},"Ventajas de las Minimal APIs"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Simplicidad: Permiten un enfoque m\xe1s directo para definir rutas y manejadores de solicitudes sin la sobrecarga de los controladores."),(0,r.yg)("li",{parentName:"ol"},"Menos C\xf3digo: Reducen la cantidad de c\xf3digo necesario para crear una API, lo que puede ser especialmente \xfatil para prototipos o aplicaciones peque\xf1as."),(0,r.yg)("li",{parentName:"ol"},"Desarrollo R\xe1pido: Facilitan un desarrollo m\xe1s r\xe1pido al eliminar la necesidad de la estructura tradicional de controladores.")),(0,r.yg)("h4",{id:"diferencias-con-los-controladores"},"Diferencias con los Controladores"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Aspecto"),(0,r.yg)("th",{parentName:"tr",align:null},"Controladores"),(0,r.yg)("th",{parentName:"tr",align:null},"Minimal APIs"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Estructura"),(0,r.yg)("td",{parentName:"tr",align:null},"Requiere clases de controlador."),(0,r.yg)("td",{parentName:"tr",align:null},"Directamente en el archivo de inicio.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"C\xf3digo"),(0,r.yg)("td",{parentName:"tr",align:null},"M\xe1s c\xf3digo, ya que cada acci\xf3n es un m\xe9todo en un controlador."),(0,r.yg)("td",{parentName:"tr",align:null},"Menos c\xf3digo, usando una sintaxis m\xe1s directa.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Uso"),(0,r.yg)("td",{parentName:"tr",align:null},"Ideal para aplicaciones m\xe1s grandes y complejas."),(0,r.yg)("td",{parentName:"tr",align:null},"Ideal para aplicaciones peque\xf1as o prototipos.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Configuraci\xf3n"),(0,r.yg)("td",{parentName:"tr",align:null},"Necesita un archivo de configuraci\xf3n m\xe1s elaborado."),(0,r.yg)("td",{parentName:"tr",align:null},"Configuraci\xf3n sencilla y directa.")))),(0,r.yg)("h4",{id:"ejemplo-de-minimal-api"},"Ejemplo de Minimal API"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Agregar servicios al contenedor, si es necesario\nbuilder.Services.AddEndpointsApiExplorer();\n\nvar app = builder.Build();\n\n// Definici\xf3n de un endpoint\napp.MapGet("/saludo", () => "\xa1Hola, mundo!");\n\napp.MapGet("/persona/{nombre}", (string nombre) => \n{\n    return $"\xa1Hola, {nombre}!";\n});\n\napp.Run();\n\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Explicaci\xf3n del ejemplo")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ol",{parentName:"div"},(0,r.yg)("li",{parentName:"ol"},"Configuraci\xf3n del Servidor: Se inicia creando un WebApplicationBuilder y configurando los servicios. Aqu\xed puedes a\xf1adir servicios si es necesario, aunque para este ejemplo no se necesitan."),(0,r.yg)("li",{parentName:"ol"},"Creaci\xf3n de la Aplicaci\xf3n: Se crea la instancia de la aplicaci\xf3n web con builder.Build()."),(0,r.yg)("li",{parentName:"ol"},"Definici\xf3n de Endpoints:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},'app.MapGet("/saludo", () => "\xa1Hola, mundo!"); define un endpoint que responde a solicitudes GET en la ruta /saludo y devuelve un saludo simple.'),(0,r.yg)("li",{parentName:"ul"},'app.MapGet("/persona/{nombre}", (string nombre) => ...) define un segundo endpoint que toma un par\xe1metro en la URL (nombre) y devuelve un saludo personalizado.'))),(0,r.yg)("li",{parentName:"ol"},"Ejecutar la Aplicaci\xf3n: Finalmente, app.Run(); inicia el servidor web."),(0,r.yg)("li",{parentName:"ol"},"Para ejecutar esta Minimal API, necesitar\xe1s un entorno de desarrollo de ASP.NET Core. Al iniciar la aplicaci\xf3n y hacer una solicitud GET a http://localhost:","<",'puerto>/saludo, recibir\xe1s la respuesta "\xa1Hola, mundo!". Si accedes a http://localhost:',"<",'puerto>/persona/Ana, obtendr\xe1s "\xa1Hola, Ana!".')))),(0,r.yg)("h2",{id:"subconjuntosrangos"},"Subconjuntos/rangos"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C#, los subconjuntos o rangos (subranges) son una caracter\xedstica que permite trabajar con partes de una colecci\xf3n (como arrays o listas) de manera m\xe1s sencilla y expresiva. Esta funcionalidad se introdujo en C# 8.0 y ofrece una manera compacta de seleccionar una porci\xf3n de una secuencia de elementos usando un \xedndice de inicio y un \xedndice de final.")),(0,r.yg)("h4",{id:"caracter\xedsticas-clave-de-los-rangos-y-subconjuntos"},"Caracter\xedsticas Clave de los Rangos y Subconjuntos"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Rangos: Los rangos permiten seleccionar un subconjunto de una colecci\xf3n usando la sintaxis de \u201c..\u201d para definir el rango de \xedndices. Por ejemplo, 1..4 selecciona los elementos desde el \xedndice 1 hasta el \xedndice 3 (el final es exclusivo)."),(0,r.yg)("li",{parentName:"ol"},"\xcdndices: Los \xedndices en C# ahora tienen una nueva funcionalidad llamada Index. Con la sintaxis de ^, puedes contar los elementos desde el final de la colecci\xf3n. Por ejemplo, ^1 es el \xfaltimo elemento, ^2 es el pen\xfaltimo, y as\xed sucesivamente."),(0,r.yg)("li",{parentName:"ol"},"Sintaxis Limpia: Utilizando rangos e \xedndices, puedes crear subconjuntos de una colecci\xf3n de manera m\xe1s clara y concisa que utilizando bucles o llamadas a m\xe9todos como Array.Copy.")),(0,r.yg)("h4",{id:"c\xf3mo-trabajar-con-rangos-e-\xedndices"},"C\xf3mo Trabajar con Rangos e \xcdndices"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con la nueva funcionalidad de rangos, puedes crear subconjuntos f\xe1cilmente de arrays o listas utilizando la sintaxis ",(0,r.yg)("inlineCode",{parentName:"li"},".. "),":")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int[] numeros = { 1, 2, 3, 4, 5, 6 };\n\n// Extraer un subconjunto desde el \xedndice 1 al \xedndice 3 (no inclusivo del \xedndice 4)\nint[] subset = numeros[1..4]; // Resultado: { 2, 3, 4 }\n\nforeach (var num in subset)\n{\n    Console.WriteLine(num);\n}\n\n")),(0,r.yg)("h4",{id:"uso-de-\xedndices-desde-el-final"},"Uso de \xcdndices desde el Final"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"El operador ^ te permite contar \xedndices desde el final de la colecci\xf3n. Esto es \xfatil cuando necesitas acceder a elementos al final de una lista sin conocer su longitud exacta:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int[] numeros = { 1, 2, 3, 4, 5, 6 };\n\n// Acceder al \xfaltimo elemento\nint ultimo = numeros[^1]; // Resultado: 6\n\n// Acceder al pen\xfaltimo elemento\nint penultimo = numeros[^2]; // Resultado: 5\n\n")),(0,r.yg)("h4",{id:"combinar-\xedndices-y-rangos"},"Combinar \xcdndices y Rangos"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Puedes combinar rangos con \xedndices negativos para obtener subconjuntos que empiecen desde el principio o el final de la colecci\xf3n:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"\nint[] numeros = { 1, 2, 3, 4, 5, 6 };\n\n// Seleccionar desde el tercer elemento hasta el \xfaltimo\nint[] subsetDesdeElTercero = numeros[2..^0]; // Resultado: { 3, 4, 5, 6 }\n\n// Seleccionar desde el primer elemento hasta el pen\xfaltimo\nint[] subsetSinElUltimo = numeros[0..^1]; // Resultado: { 1, 2, 3, 4, 5 }\n\n")),(0,r.yg)("h2",{id:"desestructuraci\xf3n"},"Desestructuraci\xf3n"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"La desestructuraci\xf3n en C# es una caracter\xedstica que permite descomponer (o desestructurar) una instancia de un objeto o una tupla en variables individuales, de manera que puedes acceder a las propiedades o valores de forma m\xe1s sencilla. Esto es especialmente \xfatil cuando est\xe1s trabajando con objetos complejos o tuplas, ya que te permite acceder r\xe1pidamente a sus valores sin necesidad de referencias expl\xedcitas a las propiedades o \xedndices.")),(0,r.yg)("h4",{id:"c\xf3mo-funciona-la-desestructuraci\xf3n"},"\xbfC\xf3mo Funciona la Desestructuraci\xf3n?"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C#, puedes desestructurar:",(0,r.yg)("ol",{parentName:"li"},(0,r.yg)("li",{parentName:"ol"},"Tuplas."),(0,r.yg)("li",{parentName:"ol"},"Objetos personalizados, como records o clases, siempre y cuando implementen un m\xe9todo de desestructuraci\xf3n.")))),(0,r.yg)("h4",{id:"desestructuraci\xf3n-de-tuplas"},"Desestructuraci\xf3n de Tuplas"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Una de las formas m\xe1s comunes de desestructuraci\xf3n es con tuplas. Las tuplas son colecciones de valores agrupados, y puedes descomponerlas en variables individuales de forma muy sencilla:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'// Crear una tupla con tres elementos\n(string nombre, int edad, string ciudad) persona = ("Juan", 30, "Madrid");\n\n// Desestructuraci\xf3n de la tupla\nvar (nombre, edad, ciudad) = persona;\n\n// Ahora tenemos tres variables individuales\nConsole.WriteLine($"Nombre: {nombre}, Edad: {edad}, Ciudad: {ciudad}");\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ol",{parentName:"div"},(0,r.yg)("li",{parentName:"ol"},'Tupla: Se define una tupla con los valores "Juan", 30, y "Madrid".'),(0,r.yg)("li",{parentName:"ol"},"Desestructuraci\xf3n: Con la l\xednea var (nombre, edad, ciudad) = persona;, descomponemos la tupla en tres variables: nombre, edad, y ciudad."),(0,r.yg)("li",{parentName:"ol"},"Uso: Ahora puedes usar estas variables de manera individual.")))),(0,r.yg)("h4",{id:"desestructuraci\xf3n-en-records"},"Desestructuraci\xf3n en Records"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Otra forma de desestructuraci\xf3n en C# es cuando trabajas con records, que son tipos de objetos inmutables introducidos en C# 9.0. Los records proporcionan una funcionalidad integrada para la desestructuraci\xf3n:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public record Persona(string Nombre, int Edad, string Ciudad);\n\nvar persona = new Persona("Ana", 25, "Barcelona");\n\n// Desestructurar el record en variables individuales\nvar (nombre, edad, ciudad) = persona;\n\nConsole.WriteLine($"Nombre: {nombre}, Edad: {edad}, Ciudad: {ciudad}");\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ol",{parentName:"div"},(0,r.yg)("li",{parentName:"ol"},"Record: Se define el record Persona con tres propiedades: Nombre, Edad, y Ciudad."),(0,r.yg)("li",{parentName:"ol"},"Desestructuraci\xf3n: Al utilizar var (nombre, edad, ciudad) = persona;, descomponemos el record persona en variables individuales, como si estuvi\xe9ramos trabajando con una tupla."),(0,r.yg)("li",{parentName:"ol"},"Uso: Las variables nombre, edad, y ciudad ahora contienen los valores de la instancia del record.")))),(0,r.yg)("h4",{id:"desestructuraci\xf3n-con-clases-personalizadas"},"Desestructuraci\xf3n con Clases Personalizadas"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Puedes habilitar la desestructuraci\xf3n en tus propias clases implementando un m\xe9todo llamado Deconstruct. Este m\xe9todo se encarga de descomponer la instancia en varios componentes. Aqu\xed tienes un ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Punto\n{\n    public int X { get; }\n    public int Y { get; }\n\n    public Punto(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    // M\xe9todo Deconstruct\n    public void Deconstruct(out int x, out int y)\n    {\n        x = X;\n        y = Y;\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var punto = new Punto(5, 10);\n\n        // Desestructurar la instancia de Punto\n        var (x, y) = punto;\n\n        Console.WriteLine($"X: {x}, Y: {y}");\n    }\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Clase Punto: Creamos una clase con dos propiedades: X y Y."),(0,r.yg)("li",{parentName:"ul"},"M\xe9todo Deconstruct: Este m\xe9todo toma dos par\xe1metros out, uno para cada valor que queremos desestructurar. Cuando desestructuramos, este m\xe9todo es invocado impl\xedcitamente para extraer las propiedades."),(0,r.yg)("li",{parentName:"ul"},"Los par\xe1metros del m\xe9todo Deconstruct representan los miembros que quieres extraer (ya sean propiedades o campos) de la clase, y eso es lo que especificas entre par\xe9ntesis cuando realizas la desestructuraci\xf3n. Dentro del m\xe9todo, t\xfa decides qu\xe9 valor se asignar\xe1 a cada uno de esos \u201cmiembros\u201d."),(0,r.yg)("li",{parentName:"ul"},"Al hacer la desestructuraci\xf3n, puedes extraer cualquiera de las variables out que se definieron en el m\xe9todo Deconstruct. Dentro de ese m\xe9todo, se especifica el valor que va a contener cada una de esas variables."),(0,r.yg)("li",{parentName:"ul"},"Cuando se usa la desestructuraci\xf3n, el compilador sabe que tiene que llamar al m\xe9todo Deconstruct para obtener los valores de los miembros de la clase y asignarlos a las variables correspondientes.")))),(0,r.yg)("h2",{id:"readonlyspant"},"ReadOnlySpan","<","T>"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T> se introdujo en C# 7.2 y es parte de las mejoras en el manejo de memoria y rendimiento en el lenguaje.")),(0,r.yg)("h4",{id:"qu\xe9-es-readonlyspant"},"\xbfQu\xe9 es ReadOnlySpan","<","T>?"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T> es un tipo de dato que representa una secuencia de elementos de un tipo determinado (T), pero solo proporciona acceso de lectura a esos elementos. Esto significa que no puedes modificar los datos a trav\xe9s de un ReadOnlySpan","<","T>, lo que lo convierte en una opci\xf3n segura para pasar datos sin permitir modificaciones."),(0,r.yg)("li",{parentName:"ul"},"Cuando se utiliza ReadOnlySpan","<","T>, no se crea una copia de los datos en memoria; en cambio, se crea una referencia a esos datos. Esto significa que el ReadOnlySpan","<",'T> act\xfaa como una "ventana" que permite ver y acceder a los elementos que ya est\xe1n en la memoria, sin duplicar o mover esos datos. La estructura ReadOnlySpan',"<","T> simplemente apunta a la misma ubicaci\xf3n en la memoria donde est\xe1n almacenados los datos originales.")),(0,r.yg)("h4",{id:"caracter\xedsticas-principales"},"Caracter\xedsticas principales"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Eficiencia de memoria:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T> permite trabajar con datos de forma eficiente sin hacer copias innecesarias. Se puede usar para referenciar porciones de arreglos, cadenas, o cualquier otra estructura de datos en memoria de manera eficiente."))),(0,r.yg)("li",{parentName:"ol"},"No necesita asignaci\xf3n de heap:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"A diferencia de otras colecciones como List","<","T>, ReadOnlySpan","<","T> no requiere la asignaci\xf3n de memoria en el heap, lo que reduce la presi\xf3n del recolector de basura y mejora el rendimiento en escenarios de alto rendimiento."))),(0,r.yg)("li",{parentName:"ol"},"Seguridad:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Al ser de solo lectura, ReadOnlySpan","<","T> ayuda a prevenir modificaciones accidentales a los datos. Esto puede ser \xfatil en situaciones donde la integridad de los datos es cr\xedtica."))),(0,r.yg)("li",{parentName:"ol"},"Operaciones seguras sobre datos:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Se puede usar en lugar de arreglos o listas cuando solo se necesita acceso de lectura, permitiendo operaciones como iteraciones y acceso a elementos sin riesgo de alteraciones.")))),(0,r.yg)("h4",{id:"ejemplo"},"Ejemplo"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Imagina que tienes un arreglo de enteros:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"int[] numeros = { 1, 2, 3, 4, 5 };\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Si deseas trabajar con esos n\xfameros sin modificarlos, puedes crear un ReadOnlySpan","<","int> que referencie el mismo bloque de memoria que el arreglo numeros:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"ReadOnlySpan<int> spanNumeros = numeros;\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"En este caso, spanNumeros ahora act\xfaa como una vista de solo lectura sobre el arreglo numeros, permiti\xe9ndote iterar sobre \xe9l o acceder a sus elementos sin permitir cambios en el contenido del arreglo original.")))),(0,r.yg)("h2",{id:"expression-bodied-member"},"expression-bodied member"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Los expression-bodied members (miembros con cuerpo de expresi\xf3n) en C# son una caracter\xedstica que permite simplificar la sintaxis de los m\xe9todos, propiedades y otros miembros de una clase o estructura utilizando una \u201cexpresi\xf3n \xfanica\u201d en lugar de un bloque de c\xf3digo. Esta caracter\xedstica fue introducida en C# 6 y se ha mejorado en versiones posteriores, como C# 7.0 y C# 8.0, para incluir m\xe1s tipos de miembros."),(0,r.yg)("li",{parentName:"ul"},"Los expression-bodied members en C# son similares a las funciones flecha (arrow functions) en JavaScript. "),(0,r.yg)("li",{parentName:"ul"},"Los expression-bodied members en C# est\xe1n espec\xedficamente dise\xf1ados para m\xe9todos, propiedades y otros miembros de clases o estructuras."),(0,r.yg)("li",{parentName:"ul"},"Los expression-bodied members en C# pueden aplicarse a propiedades, constructores y operadores, adem\xe1s de m\xe9todos.")),(0,r.yg)("h4",{id:"m\xe9todos"},"M\xe9todos"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Puedes definir un m\xe9todo que retorna un valor utilizando una expresi\xf3n simple:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class MathUtils\n{\n    public int Sumar(int a, int b) => a + b; // M\xe9todo de cuerpo de expresi\xf3n\n}\n\n\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Comparaci\xf3n con Javascript")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Permiten definir funciones o m\xe9todos en una sola l\xednea."),(0,r.yg)("li",{parentName:"ul"},"En javascript seria: ")),(0,r.yg)("pre",{parentName:"div"},(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const sumar = (a, b) => a + b;\n")),(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Tanto en C# como en JavaScript, no es necesario usar la palabra clave return si la funci\xf3n retorna en una sola l\xednea.")))),(0,r.yg)("h4",{id:"propiedades"},"Propiedades"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Las propiedades tambi\xe9n pueden ser definidas usando esta sintaxis, permitiendo que el valor de una propiedad se calcule de manera concisa:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Rectangulo\n{\n    public int Ancho { get; }\n    public int Alto { get; }\n\n    public Rectangulo(int ancho, int alto)\n    {\n        Ancho = ancho;\n        Alto = alto;\n    }\n\n    public int Area => Ancho * Alto; // Propiedad con cuerpo de expresi\xf3n\n}\n\n\n")),(0,r.yg)("h4",{id:"operadores"},"Operadores"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Puedes usar cuerpos de expresi\xf3n para definir operadores sobrecargados:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public static Rectangulo operator +(Rectangulo r1, Rectangulo r2) =>\n    new Rectangulo(r1.Ancho + r2.Ancho, r1.Alto + r2.Alto);\n\n")),(0,r.yg)("h4",{id:"constructores"},"Constructores"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En versiones m\xe1s recientes, tambi\xe9n puedes definir constructores usando la sintaxis de cuerpo de expresi\xf3n:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Punto\n{\n    public int X { get; }\n    public int Y { get; }\n\n    public Punto(int x, int y) => (X, Y) = (x, y); // Constructor con cuerpo de expresi\xf3n\n}\n\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"La sintaxis ",(0,r.yg)("inlineCode",{parentName:"li"},"(X, Y) = (x, y)")," es una asignaci\xf3n de tuplas. En este contexto, est\xe1 asignando el valor de x al campo o propiedad X y el valor de y al campo o propiedad Y. Esto permite una asignaci\xf3n m\xe1s compacta y clara.")))),(0,r.yg)("h2",{id:"spant"},"Span","<","T>"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Span","<","T> en C# es un tipo introducido en C# 7.2 que permite trabajar con secuencias de datos que est\xe1n almacenados de forma continua, uno tras otro, en la memoria. Es decir, los elementos de esa secuencia est\xe1n f\xedsicamente organizados en celdas consecutivas de memoria.")),(0,r.yg)("h4",{id:"caracter\xedsticas-clave-de-spant"},"Caracter\xedsticas clave de Span","<","T>"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"No crea copias de datos: Permite trabajar con partes de arreglos o buffers sin duplicar la informaci\xf3n. Esto es \xfatil cuando necesitas procesar solo una porci\xf3n de un arreglo, sin la sobrecarga de crear un nuevo arreglo."),(0,r.yg)("li",{parentName:"ol"},"Eficiente en t\xe9rminos de memoria y rendimiento: Al evitar la creaci\xf3n de copias adicionales de datos, Span","<","T> es muy eficiente cuando se trabaja con grandes cantidades de datos o cuando se requiere un procesamiento r\xe1pido."),(0,r.yg)("li",{parentName:"ol"},"Soporte para memoria gestionada y no gestionada: Span","<","T> puede referenciar tanto memoria gestionada (como arreglos) como memoria no gestionada (como buffers de memoria fuera del control de la recolecci\xf3n de basura)."),(0,r.yg)("li",{parentName:"ol"},"Pila (stack) en lugar de heap: Span","<","T> generalmente se asigna en la pila, lo que significa que se puede recolectar cuando sale del alcance, lo que evita la presi\xf3n sobre la recolecci\xf3n de basura (GC). Esto es diferente de los arreglos tradicionales, que se asignan en el heap."),(0,r.yg)("li",{parentName:"ol"},"Versatilidad: Puedes usar Span","<","T> con tipos como byte, char, int, o cualquier otro tipo de dato para manipular datos binarios o buffers de texto de forma eficiente.")),(0,r.yg)("h4",{id:"ejemplo-b\xe1sico-de-spant"},"Ejemplo b\xe1sico de Span","<","T>"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Ejemplo\n{\n    public static void Main()\n    {\n        int[] array = { 1, 2, 3, 4, 5, 6 };\n\n        // Crear un Span que apunte(referencie) a una porci\xf3n del arreglo\n        Span<int> span = array.AsSpan(1, 3);  // Desde el \xedndice 1, tomar 3 elementos\n\n        foreach (var item in span)\n        {\n            Console.WriteLine(item);  // Salida: 2, 3, 4\n        }\n\n        // Modificar el Span modifica el arreglo original\n        span[0] = 100;\n        Console.WriteLine(array[1]);  // Salida: 100\n    }\n}\n\n")),(0,r.yg)("h4",{id:"spant-vs-readonlyspant"},"Span","<","T> vs ReadOnlySpan","<","T>"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"La diferencia clave entre Span","<","T> y ReadOnlySpan","<","T> es que mientras ambos permiten trabajar con secuencias contiguas de datos en memoria, con ReadOnlySpan","<","T> no puedes modificar los datos subyacentes, ya que es de solo lectura.")),(0,r.yg)("h5",{id:"diferencias-principales"},"Diferencias principales"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Mutabilidad:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Span","<","T>: Te permite leer y modificar los datos en la secuencia contigua de memoria."),(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T>: Te permite solo leer los datos. No puedes modificarlos, garantizando que los datos subyacentes no cambien."))),(0,r.yg)("li",{parentName:"ol"},"Seguridad:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T> proporciona una capa adicional de seguridad porque asegura que los datos a los que apunta no ser\xe1n alterados accidentalmente. Esto es \xfatil cuando necesitas pasar referencias a datos que no deben ser modificados, como constantes o datos sensibles."))),(0,r.yg)("li",{parentName:"ol"},"Uso previsto:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Span","<","T>: \xdatil cuando necesitas manipular los datos, como al procesar o actualizar partes de un arreglo."),(0,r.yg)("li",{parentName:"ul"},"ReadOnlySpan","<","T>: Adecuado cuando solo necesitas acceder a los datos sin necesidad de modificarlos, como al realizar operaciones de lectura.")))),(0,r.yg)("h2",{id:"operadores-sobrecargados"},"Operadores sobrecargados"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Los operadores sobrecargados en C# permiten redefinir la funcionalidad de los operadores para tipos definidos por el usuario, como clases o estructuras. Esto significa que puedes hacer que operadores como +, -, ==, !=, entre otros, se comporten de una manera espec\xedfica cuando se usan con tus propios tipos."),(0,r.yg)("li",{parentName:"ul"},"En C#, los operadores son s\xedmbolos que realizan operaciones sobre variables o valores. Al sobrecargar un operador, le dices al compilador c\xf3mo debe comportarse ese operador cuando se aplica a instancias de un tipo definido por el usuario."),(0,r.yg)("li",{parentName:"ul"},"Por ejemplo, puedes sobrecargar el operador + para una clase Punto, de manera que sumar dos objetos de tipo Punto combine sus coordenadas en un nuevo punto.")),(0,r.yg)("h4",{id:"c\xf3mo-se-crea-un-operador-sobrecargado"},"\xbfC\xf3mo se crea un operador sobrecargado?"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Debe declararse como un m\xe9todo est\xe1tico."),(0,r.yg)("li",{parentName:"ul"},"Debe usar la palabra clave operator seguida del operador a sobrecargar."),(0,r.yg)("li",{parentName:"ul"},"Debe devolver un valor y tomar al menos un par\xe1metro del mismo tipo que la clase o estructura donde se define.")),(0,r.yg)("h4",{id:"operadores-que-se-pueden-sobrecargar"},"Operadores que se pueden sobrecargar"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Algunos de los operadores que puedes sobrecargar en C# incluyen:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Aritm\xe9ticos: +, -, *, /, %"),(0,r.yg)("li",{parentName:"ul"},"Comparaci\xf3n: ==, !=, <, >, <=, >="),(0,r.yg)("li",{parentName:"ul"},"Unarios: +, -, !, ~, ++, --"),(0,r.yg)("li",{parentName:"ul"},"Otros: [] (indexaci\xf3n), true, false, &, |, ^, <<, >>")))),(0,r.yg)("h4",{id:"restricciones"},"Restricciones"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"No se pueden sobrecargar algunos operadores, como &&, ||, ? : (ternario), =."),(0,r.yg)("li",{parentName:"ul"},"El operador == y != deben ser sobrecargados juntos, es decir, si sobrecargas uno, debes sobrecargar el otro."),(0,r.yg)("li",{parentName:"ul"},"Al sobrecargar operadores, tambi\xe9n es recomendable sobrecargar los m\xe9todos Equals y GetHashCode para garantizar una correcta comparaci\xf3n de objetos en escenarios m\xe1s amplios.")),(0,r.yg)("h4",{id:"ejemplo-de-sobrecarga-de-operadores"},"Ejemplo de sobrecarga de operadores"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Supongamos que tienes una clase Punto que representa un punto en un plano cartesiano:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public class Punto\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n\n    public Punto(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    // Sobrecarga del operador +\n    public static Punto operator +(Punto p1, Punto p2)\n    {\n        return new Punto(p1.X + p2.X, p1.Y + p2.Y);\n    }\n\n    // Sobrecarga del operador ==\n    public static bool operator ==(Punto p1, Punto p2)\n    {\n        return p1.X == p2.X && p1.Y == p2.Y;\n    }\n\n    // Sobrecarga del operador !=\n    public static bool operator !=(Punto p1, Punto p2)\n    {\n        return !(p1 == p2);  // Reutilizamos la sobrecarga de ==\n    }\n\n    // Es necesario sobreescribir Equals y GetHashCode cuando se sobrecargan == y !=\n    public override bool Equals(object obj)\n    {\n        if (obj is Punto)\n        {\n            var punto = (Punto)obj;\n            return this == punto;\n        }\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return (X, Y).GetHashCode();\n    }\n}\n\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Explicaci\xf3n del c\xf3digo")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Operador +: Se sobrecarga el operador + para que cuando sumes dos instancias de Punto, las coordenadas X y Y de ambos puntos se sumen y devuelvan un nuevo objeto Punto con las coordenadas resultantes."),(0,r.yg)("li",{parentName:"ul"},"Operadores == y !=: Se sobrecargan los operadores de igualdad para comparar si dos puntos son iguales o diferentes, comparando sus coordenadas. Si las coordenadas X y Y de ambos puntos son iguales, se considera que los puntos son iguales."),(0,r.yg)("li",{parentName:"ul"},"Overrides de Equals y GetHashCode: Al sobrecargar == y !=, es una buena pr\xe1ctica tambi\xe9n sobrescribir los m\xe9todos Equals y GetHashCode para que la comparaci\xf3n funcione correctamente en otras partes de la API de .NET, como colecci\xf3n.")))))}p.isMDXComponent=!0}}]);