"use strict";(self.webpackChunkdocumentacion=self.webpackChunkdocumentacion||[]).push([[814],{5680:(e,a,n)=>{n.d(a,{xA:()=>d,yg:()=>g});var r=n(6540);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function t(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,r,i=function(e,a){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var a=r.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):t(t({},a),e)),n},d=function(e){var a=c(e.components);return r.createElement(l.Provider,{value:a},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},u=r.forwardRef((function(e,a){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),u=i,g=m["".concat(l,".").concat(u)]||m[u]||p[u]||o;return n?r.createElement(g,t(t({ref:a},d),{},{components:n})):r.createElement(g,t({ref:a},d))}));function g(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=n.length,t=new Array(o);t[0]=u;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[m]="string"==typeof e?e:i,t[1]=s;for(var c=2;c<o;c++)t[c]=n[c];return r.createElement.apply(null,t)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4276:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(8168),i=(n(6540),n(5680));const o={sidebar_position:17},t="C# 12",s={unversionedId:"C--/C12",id:"C--/C12",title:"C# 12",description:"12",source:"@site/docs/C--/C12.md",sourceDirName:"C--",slug:"/C--/C12",permalink:"/documentacion/docs/C--/C12",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/C--/C12.md",tags:[],version:"current",sidebarPosition:17,frontMatter:{sidebar_position:17},sidebar:"C",previous:{title:"C# 11",permalink:"/documentacion/docs/C--/C11"},next:{title:"Pendientes",permalink:"/documentacion/docs/C--/C13"}},l={},c=[{value:"Default lambda parameters",id:"default-lambda-parameters",level:2},{value:"Params in lambda functions",id:"params-in-lambda-functions",level:2},{value:"Inline Arrays",id:"inline-arrays",level:2},{value:"Ventajas",id:"ventajas",level:4},{value:"Alias any type",id:"alias-any-type",level:2},{value:"\xbfQu\xe9 es el aliasing para tipos?",id:"qu\xe9-es-el-aliasing-para-tipos",level:4},{value:"Sintaxis",id:"sintaxis",level:4},{value:"Ejemplo pr\xe1ctico",id:"ejemplo-pr\xe1ctico",level:4},{value:"Primary Constructor",id:"primary-constructor",level:2},{value:"Ventajas de los constructores primarios",id:"ventajas-de-los-constructores-primarios",level:4},{value:"\xbfQu\xe9 es un constructor primario?",id:"qu\xe9-es-un-constructor-primario",level:4},{value:"Interceptors",id:"interceptors",level:2},{value:"\xbfQu\xe9 son los interceptors?",id:"qu\xe9-son-los-interceptors",level:4},{value:"Ventajas de los interceptors",id:"ventajas-de-los-interceptors",level:4},{value:"Ejemplo",id:"ejemplo",level:4},{value:"En proceso...",id:"en-proceso",level:4},{value:"En construcci\xf3n",id:"en-construcci\xf3n",level:2}],d={toc:c},m="wrapper";function p(e){let{components:a,...n}=e;return(0,i.yg)(m,(0,r.A)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"c-12"},"C# 12"),(0,i.yg)("h2",{id:"default-lambda-parameters"},"Default lambda parameters"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# 12, los default lambda parameters permiten definir argumentos con valores predeterminados en expresiones lambda. Antes de esta versi\xf3n, las lambdas no pod\xedan tener par\xe1metros opcionales; si un par\xe1metro estaba presente, deb\xedas pasarlo siempre que llamaras a la lambda."),(0,i.yg)("li",{parentName:"ul"},"Con esta caracter\xedstica, puedes especificar un valor predeterminado para los argumentos de una lambda. Si no se pasa un par\xe1metro al invocar la lambda, se utilizar\xe1 ese valor predeterminado:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"             var IncrementBy = (int source, int increment = 2) => source + increment;\n            Console.WriteLine(IncrementBy(10));  // increment por defecto es 2\n\n")),(0,i.yg)("h2",{id:"params-in-lambda-functions"},"Params in lambda functions"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# 12 s\xe9 permite que las lambdas utilicen el modificador params para obtener varios valores en un argumento. Esto te permite pasar un n\xfamero indefinido de argumentos a una expresi\xf3n lambda sin tener que especificar un arreglo expl\xedcitamente."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"var sum = (params int[] values) =>\n {\n     return values.Sum(x => x);\n };\n\n Console.WriteLine(sum(1, 2, 3));\n\n")),(0,i.yg)("h2",{id:"inline-arrays"},"Inline Arrays"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# 12, los inline arrays permiten trabajar con estructuras (structs) como si fueran arreglos(arrays) de tama\xf1o fijo, lo que mejora el rendimiento y reduce la sobrecarga de memoria:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Arreglo de tama\xf1o fijo: Los inline arrays permiten definir un struct que internamente funciona como un array de tama\xf1o fijo, permitiendo acceder y manipular los elementos del arreglo como si fuera un array normal."),(0,i.yg)("li",{parentName:"ul"},"Mejora de rendimiento: Al estar embebidos directamente en el struct, se elimina la necesidad de gestionar un objeto separado para el array, lo que reduce el uso de memoria y mejora la eficiencia."),(0,i.yg)("li",{parentName:"ul"},"Sintaxis familiar: Los inline arrays se pueden manejar de forma similar a los arreglos regulares en cuanto a la indexaci\xf3n (array","[0]",", array","[1]",", etc.) y en iteraciones (foreach), haci\xe9ndolos f\xe1ciles de usar sin tener que recurrir a punteros inseguros."))),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"var array = new MiArray();\narray[0] = 2;\n\nforeach (var item in array)\n{\n    Console.WriteLine(item);\n}\n\n\n[System.Runtime.CompilerServices.InlineArray(5)]\npublic struct MiArray\n{\n    private int _element;\n}\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Atributo ",(0,i.yg)("inlineCode",{parentName:"li"},"[InlineArray(x)]"),":",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"El atributo InlineArray es parte de System.Runtime.CompilerServices y le dice al compilador que debe tratar el struct como un array con un tama\xf1o fijo de x elementos, en este caso, son 5 elementos."),(0,i.yg)("li",{parentName:"ul"},"En tu ejemplo, defines MiArray con un tama\xf1o fijo de 5 elementos (como se defini\xf3 en el atributo)"))),(0,i.yg)("li",{parentName:"ul"},"Campo ",(0,i.yg)("inlineCode",{parentName:"li"},"_element"),":",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},'El campo _element en el struct act\xfaa como el "contenedor" de los elementos del array. Internamente, el compilador usa este campo como base para almacenar cada uno de los elementos del array en la memoria de la estructura.'))),(0,i.yg)("li",{parentName:"ul"},"Acceso a los elementos del array:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"A trav\xe9s del ",(0,i.yg)("inlineCode",{parentName:"li"},"array[0]"),", puedes acceder a los elementos del array como si fuera un arreglo normal. Esto es posible gracias al atributo InlineArray, que le dice al compilador c\xf3mo manejar la indexaci\xf3n."))),(0,i.yg)("li",{parentName:"ul"},"Iteraci\xf3n con foreach:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Aunque MiArray es un struct, puedes iterar sobre \xe9l como si fuera un array de tama\xf1o fijo. El compilador genera el c\xf3digo necesario para que puedas usarlo en estructuras de control como foreach."))),(0,i.yg)("li",{parentName:"ul"},"Funcionamiento detr\xe1s de escena:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"El compilador maneja la indexaci\xf3n y la capacidad de iterar sobre el struct como si fuera un array, utilizando el tama\xf1o fijo que definiste (5 elementos en este caso). El campo _element act\xfaa como un punto de referencia para todos los elementos del array en la memoria.")))))),(0,i.yg)("h4",{id:"ventajas"},"Ventajas"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Mejor rendimiento y menos sobrecarga: Los datos se almacenan directamente dentro de la estructura, eliminando la necesidad de gestionar un puntero a un array separado en memoria. Esto es m\xe1s eficiente en t\xe9rminos de uso de la memoria y mejora el rendimiento."),(0,i.yg)("li",{parentName:"ul"},"Menos objetos y referencias: Con inline arrays, no se crea un objeto en el heap para cada elemento del arreglo. En lugar de eso, todos los elementos se almacenan directamente dentro de la estructura, lo que elimina la necesidad de manejar referencias adicionales en la memoria.")),(0,i.yg)("h2",{id:"alias-any-type"},"Alias any type"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El aliasing para tipos (alias any type)  en C# 12 permite crear nombres m\xe1s legibles(alias) para tipos gen\xe9ricos, mejorando la claridad del c\xf3digo, especialmente en situaciones que implican tipos complejos. Esto no solo simplifica la escritura, sino que tambi\xe9n hace que el c\xf3digo sea m\xe1s mantenible y f\xe1cil de entender para otros desarrolladores.")),(0,i.yg)("h4",{id:"qu\xe9-es-el-aliasing-para-tipos"},"\xbfQu\xe9 es el aliasing para tipos?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El aliasing de tipos te permite asignar un nombre a un tipo gen\xe9rico o a un tipo que puede representar diferentes valores o estructuras. Esto puede ser \xfatil en varias situaciones, como en el caso de trabajar con bibliotecas que utilizan tipos gen\xe9ricos o en situaciones donde se necesita claridad en la intenci\xf3n del c\xf3digo.")),(0,i.yg)("h4",{id:"sintaxis"},"Sintaxis"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La sintaxis b\xe1sica para definir un alias de tipo en C# 12 se asemeja a la siguiente:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"using nombreAlias = System.Int32; \n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Se creo un Alias para el tipo System.Int32"),(0,i.yg)("li",{parentName:"ul"},"Lo que va despu\xe9s del \u201c=\u201d es el tipo de dato que va a \u201crepresentar\u201d el Alias.")))),(0,i.yg)("h4",{id:"ejemplo-pr\xe1ctico"},"Ejemplo pr\xe1ctico"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Supongamos que est\xe1s utilizando un tipo gen\xe9rico que puede ser un n\xfamero, una cadena o cualquier otro tipo, y deseas simplificar el c\xf3digo al darle un alias:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using MyType = System.Object;\n\nvar printValue = (MyType value) => Console.WriteLine(value);\n\n\nprintValue("Se llama con un string");\nprintValue(5);\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"MyType")," es un alias para ",(0,i.yg)("inlineCode",{parentName:"li"},"System.Object"),", lo que significa que PrintValue puede aceptar cualquier tipo de objeto."),(0,i.yg)("li",{parentName:"ul"},"Esto ayuda a simplificar la intenci\xf3n del c\xf3digo y mejora la legibilidad.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Otro ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using City = string;\n\nList<City> CityList = new List<City>();\nCityList.Add("New York");\nCityList.Add("Bogota");\nCityList.Add("Lima");\n\nforeach (City city in CityList)\n{\n    Console.WriteLine(city);\n}\n\n')),(0,i.yg)("h2",{id:"primary-constructor"},"Primary Constructor"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# 12, se introducen los constructores primarios, que simplifican la creaci\xf3n de constructores al permitir que los par\xe1metros de este se definan directamente en la declaraci\xf3n de la clase. Esto reduce la cantidad de c\xf3digo que necesitas en el constructor para inicializar propiedades y campos.")),(0,i.yg)("h4",{id:"ventajas-de-los-constructores-primarios"},"Ventajas de los constructores primarios"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Reducci\xf3n de c\xf3digo: Permite escribir menos c\xf3digo al eliminar la necesidad de declarar un constructor adicional para inicializar las propiedades."),(0,i.yg)("li",{parentName:"ol"},"Mejora de la legibilidad: Al definir los par\xe1metros directamente en la declaraci\xf3n de la clase, se hace m\xe1s claro cu\xe1les son los valores necesarios para crear una instancia de la clase."),(0,i.yg)("li",{parentName:"ol"},"Encapsulamiento: Los valores se encapsulan dentro de las propiedades, proporcionando una forma de proteger los datos mientras se inicializan.")),(0,i.yg)("h4",{id:"qu\xe9-es-un-constructor-primario"},"\xbfQu\xe9 es un constructor primario?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Un constructor primario es una forma de definir los par\xe1metros del constructor directamente en la declaraci\xf3n de la clase. Estos par\xe1metros se utilizan autom\xe1ticamente para inicializar las propiedades o campos de la clase."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'Person persona = new Person("Pedro", 18);\npersona.Age = 25;\nConsole.WriteLine(persona.Name);\nConsole.WriteLine(persona.Age);\npublic class Person(string name, int age)\n{\n    public string Name { get; set; } = name; // Inicializaci\xf3n de propiedad\n    public int Age { get; set; } = age;       // Inicializaci\xf3n de propiedad\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("p",{parentName:"div"},"En este ejemplo, name y age son par\xe1metros del constructor primario, que se utilizan para inicializar las propiedades Name y Age de la clase Person."))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Podemos a\xf1adir par\xe1metros con valores por defecto tambi\xe9n:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'Person persona = new Person("Pedro");\nConsole.WriteLine(persona.Name);\nConsole.WriteLine(persona.Age);\npublic class Person(string name , int age = 15)\n{\n    public string Name { get; set; } = name; // Inicializaci\xf3n de propiedad\n    public int Age { get; set; } = age;       // Inicializaci\xf3n de propiedad\n}\n\n')),(0,i.yg)("h2",{id:"interceptors"},"Interceptors"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# 12, se introducen los interceptors, que permiten a los desarrolladores interceptar llamadas a m\xe9todos o propiedades y modificar su comportamiento de manera flexible y reutilizable. Esta caracter\xedstica se utiliza principalmente en contextos de programaci\xf3n como aspectos, proxies y patrones de dise\xf1o que requieren comportamiento adicional o modificaci\xf3n del flujo de ejecuci\xf3n.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"aspectos, proxies y patrones de dise\xf1o")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Los aspectos son una t\xe9cnica de programaci\xf3n que forma parte de la programaci\xf3n orientada a aspectos (AOP). Esta metodolog\xeda permite modularizar el comportamiento transversal (cross-cutting concerns , significa que afectan a m\xfaltiples m\xf3dulos o componentes de una aplicaci\xf3n, pero que no est\xe1n directamente relacionados con la l\xf3gica del negocio.) de una aplicaci\xf3n, como logging, manejo de excepciones, seguridad, y transacciones (es una interacci\xf3n con una estructura de datos compleja, compuesta por varios procesos que se han de aplicar uno despu\xe9s del otro.). En lugar de dispersar este comportamiento a trav\xe9s de m\xfaltiples clases o m\xe9todos, los aspectos permiten encapsularlo en un \xfanico lugar.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Ejemplo: Sup\xf3n que tienes un sistema que necesita registrar cada vez que se llama a un m\xe9todo. En lugar de a\xf1adir c\xf3digo de logging a cada m\xe9todo, puedes crear un aspecto de logging que se aplique autom\xe1ticamente a todos los m\xe9todos relevantes."))),(0,i.yg)("li",{parentName:"ul"},"Los proxies son un patr\xf3n de dise\xf1o que act\xfaa como un intermediario o representante de otro objeto. Permite realizar acciones adicionales antes o despu\xe9s de interactuar con el objeto real. Este patr\xf3n es \xfatil en varios contextos, como:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Lazy loading: Cargar un objeto solo cuando realmente se necesita, ahorrando recursos."),(0,i.yg)("li",{parentName:"ul"},"Control de acceso: Implementar verificaciones de seguridad o permisos antes de permitir el acceso al objeto real."),(0,i.yg)("li",{parentName:"ul"},"Logging: Registrar informaci\xf3n sobre el uso del objeto, como cu\xe1ntas veces se accede a \xe9l o qu\xe9 m\xe9todos se llaman."),(0,i.yg)("li",{parentName:"ul"},"Caching: Almacenar en cach\xe9 los resultados de m\xe9todos para mejorar el rendimiento."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo: Imagina una clase Image que representa una imagen grande. En lugar de cargar la imagen en memoria inmediatamente, puedes crear un proxy ImageProxy que solo cargue la imagen cuando realmente se necesite (lazy loading). El proxy puede realizar otras acciones, como logging o validaci\xf3n, antes de llamar al objeto real."))),(0,i.yg)("li",{parentName:"ul"},"Los patrones de dise\xf1o son soluciones generales y reutilizables a problemas comunes en el dise\xf1o de software. Estos patrones son descripciones abstractas que ofrecen un enfoque para resolver problemas espec\xedficos de dise\xf1o y estructuraci\xf3n de clases. Algunos ejemplos de patrones de dise\xf1o son:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Singleton: Asegura que una clase tenga solo una instancia y proporciona un punto de acceso global a esa instancia."),(0,i.yg)("li",{parentName:"ul"},"Factory Method: Define una interfaz para crear un objeto, pero permite a las subclases decidir qu\xe9 clase instanciar."),(0,i.yg)("li",{parentName:"ul"},"Observer: Define una dependencia de uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados autom\xe1ticamente.")))))),(0,i.yg)("h4",{id:"qu\xe9-son-los-interceptors"},"\xbfQu\xe9 son los interceptors?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los interceptors son una forma de engancharse en la llamada a un m\xe9todo o acceso a una propiedad. Esto significa que puedes ejecutar c\xf3digo adicional antes o despu\xe9s de que se ejecute el m\xe9todo original, o incluso modificar el valor de retorno. Esta t\xe9cnica es \xfatil para implementar funcionalidades transversales (significa que afectan a m\xfaltiples m\xf3dulos o componentes de una aplicaci\xf3n, pero que no est\xe1n directamente relacionados con la l\xf3gica del negocio.), como la auditor\xeda, la validaci\xf3n, el manejo de excepciones y m\xe1s.")),(0,i.yg)("h4",{id:"ventajas-de-los-interceptors"},"Ventajas de los interceptors"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Separaci\xf3n de preocupaciones: Permiten mantener el c\xf3digo de negocio limpio y separado de las preocupaciones transversales (como logging, validaci\xf3n, etc.)."),(0,i.yg)("li",{parentName:"ol"},"Reutilizaci\xf3n: Los interceptors se pueden reutilizar en diferentes m\xe9todos y clases, lo que reduce la duplicaci\xf3n de c\xf3digo."),(0,i.yg)("li",{parentName:"ol"},"Flexibilidad: Puedes modificar el comportamiento de los m\xe9todos de manera din\xe1mica sin tener que cambiar la l\xf3gica interna de los m\xe9todos.")),(0,i.yg)("h4",{id:"ejemplo"},"Ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los interceptors se pueden definir creando un nuevo atributo, como Interceptor, que puedes aplicar a m\xe9todos o propiedades.")),(0,i.yg)("h4",{id:"en-proceso"},"En proceso..."),(0,i.yg)("h2",{id:"en-construcci\xf3n"},"En construcci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=gg2TuBM37oQ&ab_channel=Mteherandev"},"Todas las mejoras de C# 12 con .NET 8")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=Pg1_iMysgo8&ab_channel=NetMentor"},"Novedades C# 12 Explicadas con ejemplos")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12"},"What's new in C# 12"))))}p.isMDXComponent=!0}}]);