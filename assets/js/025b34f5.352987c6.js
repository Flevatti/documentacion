"use strict";(self.webpackChunkdocumentacion=self.webpackChunkdocumentacion||[]).push([[6978],{5680:(e,a,n)=>{n.d(a,{xA:()=>d,yg:()=>g});var o=n(6540);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function t(e,a){if(null==e)return{};var n,o,i=function(e,a){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),c=function(e){var a=o.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},d=function(e){var a=c(e.components);return o.createElement(s.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},p=o.forwardRef((function(e,a){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=t(e,["components","mdxType","originalType","parentName"]),u=c(n),p=i,g=u["".concat(s,".").concat(p)]||u[p]||m[p]||r;return n?o.createElement(g,l(l({ref:a},d),{},{components:n})):o.createElement(g,l({ref:a},d))}));function g(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=p;var t={};for(var s in a)hasOwnProperty.call(a,s)&&(t[s]=a[s]);t.originalType=e,t[u]="string"==typeof e?e:i,l[1]=t;for(var c=2;c<r;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1854:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var o=n(8168),i=(n(6540),n(5680));const r={sidebar_position:10},l='Conceptos de "C#" - Parte 5',t={unversionedId:"C--/guiaC5",id:"C--/guiaC5",title:'Conceptos de "C#" - Parte 5',description:'" - Parte 5',source:"@site/docs/C--/guiaC5.md",sourceDirName:"C--",slug:"/C--/guiaC5",permalink:"/documentacion/docs/C--/guiaC5",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/C--/guiaC5.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"C",previous:{title:'Conceptos de "C#" - Parte 4',permalink:"/documentacion/docs/C--/guiaC4"},next:{title:'Conceptos de "C#" - Parte 6',permalink:"/documentacion/docs/C--/guiaC6"}},s={},c=[{value:"Atributos",id:"atributos",level:2},{value:"Sintaxis",id:"sintaxis",level:4},{value:"C\xf3mo crear atributos",id:"c\xf3mo-crear-atributos",level:4},{value:"Crear el atributo Display Name",id:"crear-el-atributo-display-name",level:4},{value:"Consultando los atributos",id:"consultando-los-atributos",level:4},{value:"Par\xe1metros nombrados",id:"par\xe1metros-nombrados",level:4},{value:"M\xfaltiples atributos",id:"m\xfaltiples-atributos",level:4},{value:"Varios atributos",id:"varios-atributos",level:3},{value:"Conclusiones",id:"conclusiones",level:4},{value:"Using",id:"using",level:2},{value:"1- Using para importar espacios de nombres",id:"1--using-para-importar-espacios-de-nombres",level:4},{value:"2- Using static",id:"2--using-static",level:4},{value:"3- Using para crear alias",id:"3--using-para-crear-alias",level:4},{value:"4- Using para clases que implementar IDisponsable",id:"4--using-para-clases-que-implementar-idisponsable",level:4},{value:"5- Declaraciones using C# 8.0",id:"5--declaraciones-using-c-80",level:4},{value:"Typeof",id:"typeof",level:2},{value:"Diferencia entre el operador typeof y el m\xe9todo GetType",id:"diferencia-entre-el-operador-typeof-y-el-m\xe9todo-gettype",level:4},{value:"GetType",id:"gettype",level:2},{value:"Volatil",id:"volatil",level:2},{value:"Puntos clave a tener en cuenta sobre volatile:",id:"puntos-clave-a-tener-en-cuenta-sobre-volatile",level:4},{value:"Lock",id:"lock",level:2},{value:"Mejores pr\xe1cticas",id:"mejores-pr\xe1cticas",level:4},{value:"Monitor",id:"monitor",level:2},{value:"Ejemplo para comprender la clase Monitor en C# para proteger los recursos compartidos del acceso simult\xe1neo",id:"ejemplo-para-comprender-la-clase-monitor-en-c-para-proteger-los-recursos-compartidos-del-acceso-simult\xe1neo",level:4},{value:"\xbfC\xf3mo funciona la clase Monitor en C#?",id:"c\xf3mo-funciona-la-clase-monitor-en-c",level:4},{value:"M\xe9todo Monitor.Enter(lockObject, ref IslockTaken) en C#:",id:"m\xe9todo-monitorenterlockobject-ref-islocktaken-en-c",level:4},{value:"Ejemplo para comprender el m\xe9todo TryEnter(Object, TimeSpan, Boolean) de la clase Monitor en C#",id:"ejemplo-para-comprender-el-m\xe9todo-tryenterobject-timespan-boolean-de-la-clase-monitor-en-c",level:4},{value:"Ejemplo para comprender los m\xe9todos Wait() y Pulse() de la clase Monitor en C#",id:"ejemplo-para-comprender-los-m\xe9todos-wait-y-pulse-de-la-clase-monitor-en-c",level:4},{value:"Importante",id:"importante",level:4},{value:"Semaphore",id:"semaphore",level:2},{value:"\xbfC\xf3mo funciona?",id:"c\xf3mo-funciona",level:4},{value:"Sem\xe1foro usado entre m\xfaltiples procesos",id:"sem\xe1foro-usado-entre-m\xfaltiples-procesos",level:4},{value:"M\xe9todo WaitOne",id:"m\xe9todo-waitone",level:4},{value:"M\xe9todo de liberaci\xf3n",id:"m\xe9todo-de-liberaci\xf3n",level:4},{value:"Ejemplo",id:"ejemplo",level:4},{value:"ReaderWriterLockSlim",id:"readerwriterlockslim",level:2},{value:"Ejemplo",id:"ejemplo-1",level:4},{value:"Explicaci\xf3n del ejemplo",id:"explicaci\xf3n-del-ejemplo",level:4},{value:"SemaphoreSlim",id:"semaphoreslim",level:2},{value:"Concepto Sem\xe1foro",id:"concepto-sem\xe1foro",level:4},{value:"\xbfPor qu\xe9 necesitamos SemaphoreSlim si ya tenemos Lock, Monitor, Mutex y Semaphore en C#?",id:"por-qu\xe9-necesitamos-semaphoreslim-si-ya-tenemos-lock-monitor-mutex-y-semaphore-en-c",level:4},{value:"\xbfQu\xe9 es la clase SemaphoreSlim en C#?",id:"qu\xe9-es-la-clase-semaphoreslim-en-c",level:4},{value:"C\xf3mo utilizar la clase SemaphoreSlim",id:"c\xf3mo-utilizar-la-clase-semaphoreslim",level:4},{value:"Ejemplo",id:"ejemplo-2",level:4},{value:"C\xf3mo funciona",id:"c\xf3mo-funciona-1",level:4},{value:"Mutex",id:"mutex",level:2},{value:"\xbfPor qu\xe9 Mutex si ya tenemos Lock and Monitor para la seguridad de subprocesos?",id:"por-qu\xe9-mutex-si-ya-tenemos-lock-and-monitor-para-la-seguridad-de-subprocesos",level:4},{value:"\xbfQu\xe9 es la clase Mutex en C#?",id:"qu\xe9-es-la-clase-mutex-en-c",level:4},{value:"Constructores",id:"constructores",level:4},{value:"M\xe9todos",id:"m\xe9todos",level:4},{value:"Ejemplo para comprender Mutex en C# para proteger recursos compartidos en subprocesos m\xfaltiples",id:"ejemplo-para-comprender-mutex-en-c-para-proteger-recursos-compartidos-en-subprocesos-m\xfaltiples",level:4},{value:"Ejemplo de m\xe9todo OpenExisting de clase Mutex en C#",id:"ejemplo-de-m\xe9todo-openexisting-de-clase-mutex-en-c",level:4},{value:"Atributo Synchronization",id:"atributo-synchronization",level:2},{value:"Problema de la concurrencia",id:"problema-de-la-concurrencia",level:4},{value:"Soluci\xf3n",id:"soluci\xf3n",level:4},{value:"Podemos usar el atributo Synchronization",id:"podemos-usar-el-atributo-synchronization",level:4},{value:"Ejemplo",id:"ejemplo-3",level:4},{value:"Explicaci\xf3n del ejemplo",id:"explicaci\xf3n-del-ejemplo-1",level:4},{value:"Extender contexto de sincronizaci\xf3n",id:"extender-contexto-de-sincronizaci\xf3n",level:4},{value:"Reentrada",id:"reentrada",level:4},{value:"Clase InterLocked",id:"clase-interlocked",level:2},{value:"C\xf3mo funciona",id:"c\xf3mo-funciona-2",level:4},{value:"Ejemplo para entender Interlocked en C#:",id:"ejemplo-para-entender-interlocked-en-c",level:4},{value:"Clase interlocked",id:"clase-interlocked-1",level:4},{value:"Ejemplo con el m\xe9todo add()",id:"ejemplo-con-el-m\xe9todo-add",level:4},{value:"M\xe9todo Exchange y CompareExchange",id:"m\xe9todo-exchange-y-compareexchange",level:4},{value:"Interlocked vs lock",id:"interlocked-vs-lock",level:4},{value:"\xbfC\xf3mo resolver la condici\xf3n de carrera anterior?",id:"c\xf3mo-resolver-la-condici\xf3n-de-carrera-anterior",level:4},{value:"Region",id:"region",level:2},{value:"Usos del signo &quot;?&quot;",id:"usos-del-signo-",level:2},{value:"Tipos de Valor Nullable",id:"tipos-de-valor-nullable",level:4},{value:"Tipos de Referencia Nullable",id:"tipos-de-referencia-nullable",level:4},{value:"Operador Condicional Null (?.)",id:"operador-condicional-null-",level:4},{value:"Operador Null-Coalescing (??)",id:"operador-null-coalescing-",level:4},{value:"En Par\xe1metros Opcionales",id:"en-par\xe1metros-opcionales",level:4},{value:"Como compila en C#",id:"como-compila-en-c",level:2},{value:"1- Escribir el c\xf3digo fuente",id:"1--escribir-el-c\xf3digo-fuente",level:4},{value:"2- Proceso de compilaci\xf3n",id:"2--proceso-de-compilaci\xf3n",level:4},{value:"\xbfQu\xe9 pasa con los using?",id:"qu\xe9-pasa-con-los-using",level:5},{value:"\xbfQu\xe9 pasa con los m\xe9todos de extensi\xf3n?",id:"qu\xe9-pasa-con-los-m\xe9todos-de-extensi\xf3n",level:5},{value:"3- Ejecuci\xf3n del progama",id:"3--ejecuci\xf3n-del-progama",level:4},{value:"1. Compilaci\xf3n a C\xf3digo IL",id:"1-compilaci\xf3n-a-c\xf3digo-il",level:5},{value:"2. Carga de Ensambles",id:"2-carga-de-ensambles",level:5},{value:"\xbfC\xf3mo Ayuda global using al CLR?",id:"c\xf3mo-ayuda-global-using-al-clr",level:5},{value:"3. Revisar el c\xf3digo",id:"3-revisar-el-c\xf3digo",level:5},{value:"4. Verificaci\xf3n de Errores",id:"4-verificaci\xf3n-de-errores",level:5},{value:"5. Inicio de la Ejecuci\xf3n",id:"5-inicio-de-la-ejecuci\xf3n",level:5},{value:"6.Manejo de Excepciones y Recursos",id:"6manejo-de-excepciones-y-recursos",level:5},{value:"C# Sintaxis de anidaci\xf3n",id:"c-sintaxis-de-anidaci\xf3n",level:2},{value:"Anidaci\xf3n de bloques de c\xf3digo",id:"anidaci\xf3n-de-bloques-de-c\xf3digo",level:4},{value:"Anidaci\xf3n de bucles",id:"anidaci\xf3n-de-bucles",level:4},{value:"Anidaci\xf3n de clases",id:"anidaci\xf3n-de-clases",level:4},{value:"Anidaci\xf3n de funciones locales",id:"anidaci\xf3n-de-funciones-locales",level:4},{value:"Anidaci\xf3n de expresiones",id:"anidaci\xf3n-de-expresiones",level:4},{value:"Anidaci\xf3n de expresiones",id:"anidaci\xf3n-de-expresiones-1",level:4},{value:"Llaves en patr\xf3n de coincidencia",id:"llaves-en-patr\xf3n-de-coincidencia",level:2},{value:"Ejemplo con llaves",id:"ejemplo-con-llaves",level:4},{value:"Heap y Stack",id:"heap-y-stack",level:2},{value:"Stack (Pila de memoria)",id:"stack-pila-de-memoria",level:4},{value:"Caracter\xedsticas del Stack",id:"caracter\xedsticas-del-stack",level:5},{value:"Ejemplo de uso del Stack",id:"ejemplo-de-uso-del-stack",level:5},{value:"Heap (Mont\xf3n de memora)",id:"heap-mont\xf3n-de-memora",level:4},{value:"Caracter\xedsticas del Heap",id:"caracter\xedsticas-del-heap",level:5},{value:"Ejemplo de uso del Heap",id:"ejemplo-de-uso-del-heap",level:5},{value:"Comparaci\xf3n entre Stack y Heap",id:"comparaci\xf3n-entre-stack-y-heap",level:4},{value:"Ejemplo pr\xe1ctico combinando Stack y Heap",id:"ejemplo-pr\xe1ctico-combinando-stack-y-heap",level:4},{value:"Par\xe1metros posicionales",id:"par\xe1metros-posicionales",level:2},{value:"Record",id:"record",level:4},{value:"Parametros con nombres",id:"parametros-con-nombres",level:2},{value:"Ejemplo con Par\xe1metros Opcionales",id:"ejemplo-con-par\xe1metros-opcionales",level:4},{value:"Palabra clave Sealed",id:"palabra-clave-sealed",level:2},{value:"\xbfPor qu\xe9 usar sealed?",id:"por-qu\xe9-usar-sealed",level:4},{value:"Uso en M\xe9todos",id:"uso-en-m\xe9todos",level:4}],d={toc:c},u="wrapper";function m(e){let{components:a,...n}=e;return(0,i.yg)(u,(0,o.A)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"conceptos-de-c---parte-5"},'Conceptos de "C#" - Parte 5'),(0,i.yg)("h2",{id:"atributos"},"Atributos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C#, los atributos son metadatos que se asignan a elementos del c\xf3digo, como clases, tipos, m\xe9todos y campos."),(0,i.yg)("li",{parentName:"ul"},"Sirven como un mecanismo para a\xf1adir informaci\xf3n adicional sobre un elemento del c\xf3digo (es la definici\xf3n de metadato), lo cual puede incluir instrucciones para el compilador, informaci\xf3n sobre ensamblados o sobre m\xe9todos y propiedades. Estos metadatos permiten modificar el comportamiento del c\xf3digo sin alterar su l\xf3gica principal."),(0,i.yg)("li",{parentName:"ul"},"A trav\xe9s de la reflexi\xf3n, es posible inspeccionar estos atributos en tiempo de ejecuci\xf3n, lo que permite cambiar o ajustar el comportamiento del programa din\xe1micamente.")),(0,i.yg)("h4",{id:"sintaxis"},"Sintaxis"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En pocas palabras, los atributos son etiquetas de metadatos que contienen cierta informaci\xf3n. La sintaxis para ellos es el nombre del atributo entre corchetes sobre el c\xf3digo que se etiqueta, as\xed:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"[Attribute]\nvoid Command() \n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Se pueden adjuntar a pr\xe1cticamente cualquier cosa: clases, m\xe9todos, campos, estructuras, tipos, etc. Incluso se les pueden dar par\xe1metros de entrada, aunque est\xe1n limitados a tipos b\xe1sicos. "),(0,i.yg)("li",{parentName:"ul"},"Puede establecer par\xe1metros invocando el atributo como un m\xe9todo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'[Attribute("name", Test=false, Number=42)]\n')),(0,i.yg)("h4",{id:"c\xf3mo-crear-atributos"},"C\xf3mo crear atributos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Para crear un atributo debemos crear una clase que herede de Attribute. Adem\xe1s, podemos especificar algunas propiedades utilizando el atributo AttributeUsage."),(0,i.yg)("li",{parentName:"ul"},"Con este atributo podemos indicar (con parametros posicionales):",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"ValidOn: elementos v\xe1lidos para el atributo que vamos a crear."),(0,i.yg)("li",{parentName:"ul"},"AllowMultiple: nos indica si el atributo se puede especificar m\xe1s de una vez para un mismo elemento. Por defecto false."),(0,i.yg)("li",{parentName:"ul"},"Inherited: nos indica si el atributo lo pueden heredar las clases derivadas. Por defecto false."))),(0,i.yg)("li",{parentName:"ul"},"Antes de seguir debemos hacer una diferenciaci\xf3n entre par\xe1metros posicionales y par\xe1metros con nombre:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Los par\xe1metros posicionales son obligatorios y los especificaremos en el constructor del atributo mientras que los par\xe1metros con nombre, que son opcionales, los especificaremos como propiedades y deberemos nombrarlos al usar el atributo.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Los par\xe1metros de los atributos deben ser un valor constante de un tipo simple (string, enum, Type\u2026).")))),(0,i.yg)("h4",{id:"crear-el-atributo-display-name"},"Crear el atributo Display Name"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En este ejemplo vamos a tener un solo par\xe1metro posicional llamado DisplayName que ser\xe1 el texto a mostrar."),(0,i.yg)("li",{parentName:"ul"},"Para crear nuestro atributo DisplayName debemos crear una clase que herede de Attribute. Como vamos a a\xf1adirle este atributo a cada valor de un enumerado le indicaremos que el ValidOn es Field:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'[AttributeUsage(AttributeTargets.Field)]\npublic class DisplayNameAttribute : Attribute\n{\n  public readonly string DisplayName;\n\n  public DisplayNameAttribute(string displayName)\n  {\n      DisplayName = displayName;\n  }\n}\n\npublic enum Fruit\n{\n   [DisplayName("Lemon")]\n   Lemon,\n   [DisplayName("Watermelon")]\n   Watermelon,\n   [DisplayName("Orange")]\n   Orange,\n   [DisplayName("Blood Orange")]\n   BloodOrange,\n   [DisplayName("Kiwi")]\n   Kiwi,\n   [DisplayName("Banana")]\n   Banana\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El nombre del atributo es el nombre de la clase, pero sin el sufijo \u201cAttribute\u201d.")))),(0,i.yg)("h4",{id:"consultando-los-atributos"},"Consultando los atributos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora que hemos enriquecido nuestro enumerado necesitamos tener una forma de poder consultar la nueva informaci\xf3n. Para ello vamos a utilizar reflexi\xf3n."),(0,i.yg)("li",{parentName:"ul"},"Con el siguiente m\xe9todo obtenemos todos los atributos de un determinado tipo del enumerado pasado por par\xe1metro:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"private static IEnumerable<T> GetAttributes<T>(Enum enumValue) where T : Attribute\n{\n  // Obtenemos el tipo\n  var type = enumValue.GetType();\n  // La informaci\xf3n del valor concreto del enumerado\n  var memberInfo = type.GetMember(enumValue.ToString());\n  // Obtenemos todos los atributos del miembro\n  var attributes = memberInfo[0].GetCustomAttributes(typeof(T), false);\n\n  return attributes.Cast<T>();\n} \n\nprivate static T GetFirstOrDefaultAttribute<T>(Enum enumValue) where T : Attribute\n{\n  var attributes = GetAttributes<T>(enumValue);\n  return attributes.FirstOrDefault() as T;\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Para que sea m\xe1s sencillo e intuitivo de utilizar vamos a crear un m\xe9todo de extensi\xf3n que nos devuelva el display name. Simplemente una vez tenemos el atributo obtenemos el miembro p\xfablico DisplayName:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"public static string GetDisplayName(this Enum enumValue)\n{\n  var attribute = GetFirstOrDefaultAttribute<DisplayNameAttribute>(enumValue);\n  return attribute != null ? attribute.DisplayName : string.Empty;\n}\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora podemos utilizar el m\xe9todo GetDisplayName para obtener el DisplayName de un enumerado:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Fruit.BloodOrange.GetDisplayName();\nFruit.Watermelon.GetDisplayName();\nFruit.Lemon.GetDisplayName();\n\n")),(0,i.yg)("h4",{id:"par\xe1metros-nombrados"},"Par\xe1metros nombrados"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En este ejemplo vemos c\xf3mo definir atributos con nombre y c\xf3mo especificarlos a la hora de usarlo.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"[AttributeUsage(AttributeTargets.Field)]\npublic class CenturyDataAttribute : Attribute\n{\n  private int startYear;\n\n  public int StartYear\n  {\n      get { return startYear; }\n      set { startYear = value; }\n  }\n\n  private int endYear;\n\n  public int EndYear\n  {\n      get { return endYear; }\n      set { endYear = value; }\n  }\n\n  public readonly string DisplayName;\n\n  public CenturyDataAttribute(string displayName)\n  {\n      DisplayName = displayName;\n  }\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Como vemos, basta con a\xf1adir una propiedad en el atributo para definir un par\xe1metro con nombre."),(0,i.yg)("li",{parentName:"ul"},"A la hora de usarlo simplemente nombramos los par\xe1metros y le asignamos un valor despu\xe9s de los par\xe1metros posicionales:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public enum Century\n{\n  [CenturyData("15th", StartYear = 1401, EndYear = 1500)]\n  XV,\n  [CenturyData("16th", StartYear = 1501, EndYear = 1600)]\n  XVI,\n  [CenturyData("17th", StartYear = 1601, EndYear = 1700)]\n  XVII,\n  [CenturyData("18th", StartYear = 1701, EndYear = 1800)]\n  XVIII,\n  [CenturyData("19th", StartYear = 1801, EndYear = 1900)]\n  XIX,\n  [CenturyData("20th", StartYear = 1901, EndYear = 2000)]\n  XX\n}\n\n')),(0,i.yg)("h4",{id:"m\xfaltiples-atributos"},"M\xfaltiples atributos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En este caso queremos mostrar por pantalla unas categor\xedas para el filtrado de datos. Una vez el usuario seleccione una categor\xeda se debe hacer una llamada a una API."),(0,i.yg)("li",{parentName:"ul"},"Surgen dos problemas: por un lado, por pantalla se debe ver un texto amigable para cada categor\xeda y por otro lado necesitamos saber el valor de cada categor\xeda en el API (que adem\xe1s es un valor m\xfaltiple)."),(0,i.yg)("li",{parentName:"ul"},"Para poder mostrar un texto amigable por pantalla para cada categor\xeda basta con a\xf1adir el atributo DisplayName que hemos creado antes. Y para obtener el valor que tiene en el API crearemos otro atributo llamado ApiValue. En este caso el atributo ApiValue se podr\xe1 asignar varias veces a un elemento:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]\npublic class ApiValueAttribute : Attribute\n{\n  public readonly string ApiValue;\n\n  public ApiValueAttribute(string apiValue)\n  {\n    ApiValue = apiValue;\n  }\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora simplemente en nuestro enumerado ya podemos especificar el nombre a mostrar y los diferentes valores que tienen las categor\xedas en el API.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public enum Category\n{\n  [DisplayName("Series")]\n  [ApiValue("series")]\n  [ApiValue("tv-series")]\n  [ApiValue("tv-vod")]\n  Series,\n  [DisplayName("Films and Movies")]\n  [ApiValue("movies")]\n  [ApiValue("films")]\n  Films,\n  [DisplayName("Documentary")]\n  [ApiValue("tv-documentary")]\n  Documentary\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Al igual que antes obtenemos la informaci\xf3n del enumerado gracias a su atributo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public static string GenerateQuery(this Enum enumValue)\n{\n  var attributes = GetAttributes<ApiValueAttribute>(enumValue);\n  IEnumerable<string> values = attributes.Select(attribute => attribute.ApiValue);\n\n  return $"{string.Join(",", values)}";\n}\n\n')),(0,i.yg)("h3",{id:"varios-atributos"},"Varios atributos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},'Se pueden agregar varios atributos  a un elemento en un corchete, para esto los atributos se separan con coma(",").'),(0,i.yg)("li",{parentName:"ul"},"El orden en que se especifican los atributos en los corchetes no es significativo."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'[Author("Brian Kernighan"), Author("Dennis Ritchie")] \nclass Class1\n{\n    ...\n}\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},'En el elemento "Clase", especificamos dos atributos Author.')))),(0,i.yg)("h4",{id:"conclusiones"},"Conclusiones"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Como hemos visto, los atributos son muy potentes para a\xf1adir informaci\xf3n a elementos. En nuestro caso lo hemos visto para trabajar con enumerados, pero como hemos visto en los ejemplos del principio en C# se pueden utilizar para muchos usos."),(0,i.yg)("li",{parentName:"ul"},"Por otro lado, no debemos abusar de su uso y siempre debemos plantearnos si tienen sentido o no. Como con todo, hay que tener cuidado al usarlos ya que tenemos que tener en cuenta el abuso de la reflexi\xf3n, adem\xe1s del abuso de decoradores que dificultan la legibilidad del c\xf3digo."),(0,i.yg)("li",{parentName:"ul"},"La otra cosa a tener en cuenta es que los par\xe1metros de los atributos solo pueden ser valores constantes y en muchos casos nos puede limitar.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.nocountryforgeeks.com/atributos-en-c/"},"Atributos en C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://es.linux-console.net/?p=7020#gsc.tab=0"},"\xbfC\xf3mo funcionan los atributos en C#?")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.w3big.com/es/csharp/csharp-attribute.html#gsc.tab=0"},"propiedades de C # (atributo)")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.macoratti.net/18/04/c_atrib1.htm"},"C# - Apresentando Atributos")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/advanced-topics/reflection-and-attributes/accessing-attributes-by-using-reflection"},"Acceso a atributos mediante reflexi\xf3n")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/visual-basic/programming-guide/concepts/attributes/common-attributes"},"Common Attributes (Visual Basic) (Atributos comunes [Visual Basic])")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/language-specification/attributes"},"Atributos")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/attributes/general"},"Varios atributos interpretados por el compilador de C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/advanced-topics/reflection-and-attributes/attribute-tutorial"},"Definici\xf3n y lectura de atributos personalizados")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/advanced-topics/reflection-and-attributes/creating-custom-attributes"},"Creaci\xf3n de atributos personalizados"))))),(0,i.yg)("h2",{id:"using"},"Using"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},'Cada lenguaje de programaci\xf3n cuenta con un conjunto de palabras claves que son utilizadas por el compilador. En esta secci\xf3n te mostramos 5 formas de usar la palabra reservada using de C# con el cl\xe1sico "Hola mundo".'),(0,i.yg)("li",{parentName:"ul"},"Un programa Hola Mundo sin la instrucci\xf3n luce de la siguiente manera:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'namespace Using\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            System.Console.WriteLine("Hola Mundo : sin using");\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},'B\xe1sicamente se observa que es necesario escribir el nombre completo (incluyendo el espacio de nombre) de los tipos de datos que utiliza el programa, en este caso "System.Console.WriteLine".'),(0,i.yg)("li",{parentName:"ul"},"Esto no es un problema para programas simples y sin sentido como este, pero en un programa m\xe1s complejo en el que se utilizan varias clases esto se vuelve un martirio.")))),(0,i.yg)("h4",{id:"1--using-para-importar-espacios-de-nombres"},"1- Using para importar espacios de nombres"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},'Con la instrucci\xf3n "using System" a principio del programa es posible reducir el enunciado "System.Console.WriteLine("Hola Mundo : sin using");" por "Console.WriteLine("using espacios de nombres");":')),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\nnamespace Using\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine("using para importar espacios de nombres");\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este caso permite usar el m\xe9todo est\xe1tico WriteLine sin escribir el espacio de nombres de la clase Console.")))),(0,i.yg)("h4",{id:"2--using-static"},"2- Using static"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Se utiliza \u201cusing static\u201d para importar miembros est\xe1ticos"),(0,i.yg)("li",{parentName:"ul"},"En la versi\xf3n 6.0 de C#, liberada en 2015, agregaron esta nueva caracter\xedstica que es especialmente \xfatil cuando nuestro programa hace un gran uso de miembros est\xe1ticos (m\xe9todos ,campos y propiedades) ya sea de un framework o codigo escrito por nosotros. "),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using static System.Console;\n\nnamespace Using\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine("Hello World!");\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"La caracter\xedstica using static tambi\xe9n funciona con enumeraciones."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://twitter.com/STeplyakov/status/1075277979603722240/photo/1"},"Ejemplo"))))),(0,i.yg)("h4",{id:"3--using-para-crear-alias"},"3- Using para crear alias"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En raras ocasiones, pero si pasa, dos o m\xe1s tipos  de datos tienen el mismo nombre pero est\xe1n en diferentes ensamblados, si ambos se usan en una clase ocurre una colisi\xf3n de nombres y el compilador no sabe cu\xe1l tipo elegir y lo que es peor, using para importar espacio de nombres no ayuda."),(0,i.yg)("li",{parentName:"ul"},'Podemos crear un alias para un tipo de dato usando la palabra using seguida del alias igualando con el nombre completo de la clase: "using Consola = System.Console;".'),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using Consola = System.Console;\n\nnamespace Using\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Consola.WriteLine("using para crear un alias");\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Con el alias se resuelve el problemas de las colisi\xf3n de nombres y la clase System.Console es identificada como Consola. Esto solo afecta la clase en la que se declara el alias.")))),(0,i.yg)("h4",{id:"4--using-para-clases-que-implementar-idisponsable"},"4- Using para clases que implementar IDisponsable"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El ultimo caso es cuando una clase implementa la interfaz IDisposable esto asegura que tendr\xe1 el m\xe9todo Dispose que es utilizado para liberar recursos no administrados como un archivo, una conexi\xf3n de red, una conexi\xf3n con base de datos entre otros. "),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'namespace Using\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            using (System.IO.StreamReader lector = System.IO.File.OpenText("archivo.txt"))\n            {\n                System.Console.WriteLine(lector.ReadToEnd());\n            }\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Esto asegura que se ejecute el m\xe9todo Dispose de la clase StreamReader al terminar el bloque de c\xf3digo encerrado por el enunciado using.")))),(0,i.yg)("h4",{id:"5--declaraciones-using-c-80"},"5- Declaraciones using C# 8.0"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"B\xe1sicamente permite declarar una variable despu\xe9s de la palabra reservada using."),(0,i.yg)("li",{parentName:"ul"},"Con esto se establece que el recurso declarado debe ser liberado al final del alcance(scope) donde se declar\xf3."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, para declarar una conexion tenemos las siguientes dos opciones:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"static void Main(string[] args)\n{\n    using (SqlConnection connection = new SqlConnection()))\n    {\n      // Realizar operaciones con la conexi\xf3n\n    } // aqu\xed se libera la conexion\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Con las declaraciones using de C# 8.0 el codigo se veria de la siguiente manera:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"static void Main(string[] args)\n{\n    using SqlConnection connection = new SqlConnection());\n    // Realizar operaciones con la conexi\xf3n  \n}   // aqu\xed se libera la conexion\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://aspnetcoremaster.com/c%23/dotnet/using/2019/01/03/cuatro-formas-de-usar-la-palabra-clave-using-de-csharp.html"},"Cuatro formas de usar la palabra clave using de C#"))))),(0,i.yg)("h2",{id:"typeof"},"Typeof"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Typeof es una palabra clave que se utiliza para obtener el tipo de dato en tiempo de compilaci\xf3n.  O en otras palabras, este operador se utiliza para obtener el objeto System.Type para un tipo de dato."),(0,i.yg)("li",{parentName:"ul"},"El argumento del operador typeof debe ser el nombre de un tipo de dato o un par\xe1metro de tipo generico."),(0,i.yg)("li",{parentName:"ul"},"El argumento no debe ser un tipo que requiera anotaciones de metadatos. Algunos tipos de ejemplo son:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"dynamic."),(0,i.yg)("li",{parentName:"ul"},"string? (o cualquier tipo de referencia que acepte valores NULL)."),(0,i.yg)("li",{parentName:"ul"},"Estos tipos no se representan directamente en los metadatos. Los tipos incluyen atributos que describen el tipo subyacente. En ambos casos se puede usar el tipo subyacente. En lugar de dynamic, se puede usar object. En lugar de string?, se puede usar string."))),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"\nusing System;\n \nclass GFG {\n    static Type a = typeof(double);\n    static void Main()\n    {\n        Console.WriteLine(a);\n        Console.WriteLine(typeof(int));\n        Console.WriteLine(typeof(Array));\n        Console.WriteLine(typeof(char));\n        Console.WriteLine(typeof(int[]));\n        Console.WriteLine(typeof(string));\n    }\n}\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Devuelve:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"System.Double\nSystem.Int32\nSystem.Array\nSystem.Char\nSystem.Int32[]\nSystem.String\n")),(0,i.yg)("h4",{id:"diferencia-entre-el-operador-typeof-y-el-m\xe9todo-gettype"},"Diferencia entre el operador typeof y el m\xe9todo GetType"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Operador typeof"),(0,i.yg)("th",{parentName:"tr",align:null},"M\xe9todo GetType"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Toma el tipo de dato  como argumento y devuelve el tipo de dato marcado en el  argumento."),(0,i.yg)("td",{parentName:"tr",align:null},"Solo se invoca en la instancia de un tipo de dato.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Se utiliza para obtener un tipo de dato  en tiempo de compilaci\xf3n."),(0,i.yg)("td",{parentName:"tr",align:null},"Se utiliza para obtener el tipo de dato de un objeto en tiempo de ejecuci\xf3n.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"No se puede utilizar en una instancia."),(0,i.yg)("td",{parentName:"tr",align:null},"Se puede utilizar en una instancia.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\n \npublic class GFG {\n \n \n    static public void Main()\n    {\n        string s = "Geeks";\n \n      \n        Type a1 = typeof(string);\n \n      \n        Type a2 = s.GetType();\n \n        // True\n        Console.WriteLine(a1 == a2);\n \n     \n        object obj = "Hello";\n \n  \n        Type b1 = typeof(object);\n \n     \n        Type b2 = obj.GetType();\n \n       // False\n        Console.WriteLine(b1 == b2);\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Devuelve:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Verdadero\nFALSO\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},'Aqu\xed,  "b1 = typeof(object);"  devolver\xe1 "System.Object" pero "Type b2 = obj.GetType();" devolver\xe1 "System.String" .'),(0,i.yg)("li",{parentName:"ul"},'Como, en tiempo de compilaci\xf3n solo se crea la referencia de tipo  objeto, pero en tiempo de ejecuci\xf3n la cadena ("Hello") en realidad se almacena en ella.')))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.educative.io/answers/what-is-the-typeof-method-in-c-sharp"},"What is the typeof() method in C#?")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/operators/type-testing-and-cast"},"Operadores de prueba de tipos y expresi\xf3n de conversi\xf3n: is, as, typeof y conversiones")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/typeof-operator-keyword-in-c-sharp/"},"typeof Operador Palabra clave en C#"))))),(0,i.yg)("h2",{id:"gettype"},"GetType"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los tipos de datos en C# cuentan con una clase de representaci\xf3n (representa un tipo de dato) o delegada (se encarga de representar a un tipo de dato) conocida como System.Type, la cual se puede ver como una instancia que conoce todo acerca de un tipo de dato del Framework .NET o de los propios definidos por el usuario."),(0,i.yg)("li",{parentName:"ul"},"GetType() obtiene el Type de la instancia actual (devuelve lo mismo que typeof)."),(0,i.yg)("li",{parentName:"ul"},"Entonces obtiene el Type que contiene una instancia en tiempo de ejecuci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'    using System;    \n    public class StringExample    \n    {    \n        public static void Main(string[] args)    \n        {    \n          string s1 = "Hello C#";  \n          Console.WriteLine(s1.GetType());  \n        }    \n    }    \n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Devuelve:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"System.String\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Todos los tipos de datos son Objetos.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.javatpoint.com/csharp-string-gettype"},"C# String GetType()")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.object.gettype?view=net-7.0"},"Object.GetType Method")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.type.gettype?view=net-7.0"},"Type.GetType Method")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.tutorialspoint.com/chash-object-gettype-method-with-examples"},"C# Object.GetType() Method with Examples")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.educba.com/c-sharp-get-type-of-object/"},"C# get type of object")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://ortizol.blogspot.com/2014/04/el-metodo-gettype-y-el-operador-typeof.html"},"El M\xe9todo GetType y el Operador typeof en C#"))))),(0,i.yg)("h2",{id:"volatil"},"Volatil"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La palabra clave volatile se utiliza para indicar que el valor de un campo puede ser cambiado por varios subprocesos y el compilador o el hardware no debe optimizarlo ni almacenarlo en cach\xe9."),(0,i.yg)("li",{parentName:"ul"},"Cuando un campo est\xe1 marcado como volatile, el compilador garantiza que cada lectura y escritura en ese campo se realice directamente desde la memoria, evitando cualquier optimizaci\xf3n que pueda generar un comportamiento inesperado en escenarios multiproceso."),(0,i.yg)("li",{parentName:"ul"},"La palabra clave volatile asegura la visibilidad de una variable para todos los hilos. En t\xe9rminos simples, cuando marcamos un campo volatile, le declaramos al compilador que varios subprocesos acceder\xe1n a este campo espec\xedfico y, por lo tanto, no aplicara ciertas optimizaciones de reordenamiento de memoria en ese campo."),(0,i.yg)("li",{parentName:"ul"},"Cuando un hilo lee un campo volatile, siempre lee el valor m\xe1s reciente del campo ya que el compilador no reordena ninguna operaci\xf3n de memoria que se haya realizado en este campo. De manera similar, al escribir en un campo volatile, el compilador garantiza que las operaciones de memoria anteriores no se reordenen para aparecer despu\xe9s de la \xfaltima operaci\xf3n de escritura.\nEsto garantiza que un cambio realizado por un subproceso sea visible para todos los subprocesos en todo momento. "),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"public class ExampleClass\n{\n    public volatile int VolatileField;\n\n  \n     // Otros miembros y m\xe9todos de la clase van aqu\xed.\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En este ejemplo, VolatileField est\xe1 marcado como volatile, lo que indica que varios subprocesos pueden acceder a \xe9l y modificarlo simult\xe1neamente sin ninguna optimizaci\xf3n del compilador ni del hardware que pueda generar inconsistencia en los datos.")),(0,i.yg)("h4",{id:"puntos-clave-a-tener-en-cuenta-sobre-volatile"},"Puntos clave a tener en cuenta sobre volatile:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"La palabra clave volatile se utiliza normalmente en aplicaciones de subprocesos m\xfaltiples cuando se trata de campos compartidos a los que acceden varios subprocesos al mismo tiempo."),(0,i.yg)("li",{parentName:"ol"},"Volatile no se utiliza para sincronizaci\xf3n; solo garantiza la visibilidad y la atomicidad de las operaciones de lectura y escritura individuales. Si necesita sincronizaci\xf3n para hacer cumplir el orden o la exclusi\xf3n mutua, considere usar otros mecanismos de sincronizaci\xf3n como lock, Monitor o Semaphore.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Atomicidad")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"La atomicidad es la propiedad que asegura que una operaci\xf3n se ha realizado o no, y por lo tanto ante un fallo del sistema no puede quedar a medias."),(0,i.yg)("li",{parentName:"ul"},"Si esta operaci\xf3n consiste en una serie de pasos, todos ellos ocurren o ninguno. Por ejemplo, en el caso de una transacci\xf3n bancaria o se ejecuta tanto el dep\xf3sito y la deducci\xf3n o ninguna acci\xf3n es realizada."),(0,i.yg)("li",{parentName:"ul"},"El concepto es relevante cuando se programa con hilos de ejecuci\xf3n.")))),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"En C#, cuando se trabaja con datos compartidos en escenarios de subprocesos m\xfaltiples, generalmente se recomienda usar la palabra clave lock u otras construcciones de sincronizaci\xf3n de subprocesos, ya que volatile por s\xed solas podr\xedan no ser suficientes para requisitos de sincronizaci\xf3n complejos.")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A continuaci\xf3n se muestra un ejemplo de uso volatile en un escenario de subprocesos m\xfaltiples:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class SharedData\n{\n    public volatile bool IsDataReady;\n\n    public void LoadData()\n    {\n        // Simulando que se esta cargando datos..\n        Thread.Sleep(1000);\n\n        IsDataReady = true;\n    }\n}\n\npublic class Program\n{\n    static void Main()\n    {\n        SharedData sharedData = new SharedData();\n\n        // Hilo 1: Carga datos.\n        new Thread(sharedData.LoadData).Start();\n\n        // Hilo 2: Esperando a que la data esta lista.\n        while (!sharedData.IsDataReady)\n        {\n            Console.WriteLine("Esperando la data...");\n            Thread.Sleep(100);\n        }\n\n        Console.WriteLine("\xa1Los datos est\xe1n listos!");\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este ejemplo, tenemos una clase  SharedData con un campo  IsDataReadymarcado como volatile. "),(0,i.yg)("li",{parentName:"ul"},"El hilo 1 carga datos y  establece IsDataReady en true. El hilo 2 comprueba continuamente el valor de IsDataReady hasta que se convierte en true. "),(0,i.yg)("li",{parentName:"ul"},'La palabra clave volatile garantiza que el cambio realizado por el subproceso 1 sea inmediatamente visible para el subproceso 2 y que el programa genere "\xa1Los datos est\xe1n listos!" cuando se cargan los datos.')))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.techieclues.com/tutorials/csharp-keywords/volatile-keyword-in-csharp"},"Understanding the 'volatile' Keyword in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dev.to/rogeliogamez92/why-you-should-never-use-datetimenow-directly-dealing-with-volatile-dependencies-in-c-901"},"Why you should never use DateTime.Now directly - Dealing with Volatile Dependencies in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://code-maze.com/csharp-volatile-interlocked-lock/"},"Synchronization Mechanisms \u2013 Volatile vs Interlocked vs lock in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile"},"volatile (C# Reference)"))))),(0,i.yg)("h2",{id:"lock"},"Lock"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Una de las limitaciones que tenemos con volatile es que, si bien funciona bien para tipos de datos m\xe1s simples como int, bool o char, no admite tipos de datos m\xe1s grandes como long, double o decimal. Esto se debe a que los tipos de datos m\xe1s grandes ocupan m\xe1s de 32 bits de memoria, que es mayor que una palabra de CPU y, por lo tanto, pueden requerir m\xfaltiples instrucciones de CPU para una lectura/escritura. Hace que sea dif\xedcil garantizar la atomicidad en estos tipos. Esto se puede solucionar con la palabra clave Lock."),(0,i.yg)("li",{parentName:"ul"},"En C#, la palabra clave lock nos proporciona un mecanismo tal que s\xf3lo un hilo puede acceder a un c\xf3digo particular a la vez. Una vez que un subproceso bloquea un recurso compartido para usarlo, todos los dem\xe1s subprocesos que intentan acceder al recurso deben esperar hasta que el subproceso libere el bloqueo del recurso."),(0,i.yg)("li",{parentName:"ul"},"Comencemos con un programa simple:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'int counter = 0;\nvoid Increase()\n{\n    for (int i = 0; i < 1000000; i++)\n    {\n        counter++;\n    }\n    Console.WriteLine("The counter is " + counter);\n}\n\nTask.Run(() => Increase());\nTask.Run(() => Increase());\n\nConsole.ReadLine();\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Creamos dos tareas que se ejecutan en subprocesos separados. Cada tarea ejecuta el m\xe9todo  Increase() para aumentar la variable counter."),(0,i.yg)("li",{parentName:"ul"},"Debido a que ambas tareas modifican la variable counter al mismo tiempo, existe el riesgo de que se produzcan condiciones de carrera y problemas de sincronizaci\xf3n.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Condici\xf3n de carrera")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Una condici\xf3n de carrera es una situaci\xf3n indeseable que ocurre cuando un dispositivo o sistema intenta realizar dos o m\xe1s operaciones al mismo tiempo, pero debido a la naturaleza del dispositivo o sistema, las operaciones deben realizarse en la secuencia adecuada para que se realicen correctamente.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando el programa aumenta la variable counter, lleva tres pasos:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Leer el valor de la variable counter."),(0,i.yg)("li",{parentName:"ol"},"Aumentarlo en uno."),(0,i.yg)("li",{parentName:"ol"},"Escribe el nuevo valor nuevamente en la variable counter.")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"En otras palabras, el aumento de la variable counter no es una operaci\xf3n at\xf3mica .")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Operaci\xf3n at\xf3mica")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Se dice que una operaci\xf3n es at\xf3mica cuando se completa de principio a fin sin interrupciones (no hay pasos intermedios).")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Por lo tanto, una tarea puede leer el valor de counter antes de que la otra tarea haya terminado de actualizarlo, lo que resulta en un valor incorrecto o una actualizaci\xf3n perdida."),(0,i.yg)("li",{parentName:"ul"},"Por eso lock viene al rescate."),(0,i.yg)("li",{parentName:"ul"},"La declaraci\xf3n  lock previene condiciones de carrera y garantiza la seguridad de los subprocesos cuando varios subprocesos acceden a la misma variable compartida."),(0,i.yg)("li",{parentName:"ul"},"Para usar la declaraci\xf3n lock, crea un nuevo objeto que sirve como bloqueo, que tambi\xe9n se conoce como mutex. El mutex significa exclusi\xf3n mutua:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"lock(lockObject)\n{\n   // Acceso al recurso compartido\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando un hilo ingresa a un bloque lock, intentar\xe1 adquirir el bloqueo en el objeto mutex especificado (lockObject en este caso)."),(0,i.yg)("li",{parentName:"ul"},"Si otro subproceso ya ha adquirido el bloqueo, el subproceso actual se bloquea hasta que se libere el bloqueo."),(0,i.yg)("li",{parentName:"ul"},"Una vez que se libera el bloqueo, el hilo actual puede adquirirlo y ejecutar el c\xf3digo del bloque lock que a menudo lee o escribe los recursos compartidos."),(0,i.yg)("li",{parentName:"ul"},"El siguiente programa demuestra c\xf3mo utilizar una declaraci\xf3n  lock para evitar una condici\xf3n de carrera entre dos subprocesos:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'int counter = 0;\n\nobject lockCounter = new();\nvoid Increase()\n{\n    for (int i = 0; i < 1000000; i++)\n    {\n    \n        lock (lockCounter)      // Intenta adquirir el bloqueo\n        { \n            counter++; \n        } // Se libera el bloqueo\n\n    }\n    Console.WriteLine("The counter is " + counter);\n}\n\nTask.Run(() => Increase());\nTask.Run(() => Increase());\n\nConsole.ReadLine();\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Este programa es similar al programa anterior, pero utiliza una declaraci\xf3n de bloqueo para sincronizar el acceso a la variable counter."),(0,i.yg)("li",{parentName:"ul"},"La declaraci\xf3n lock garantiza que ambas tareas accedan a la variable counter de forma mutuamente excluyente."),(0,i.yg)("li",{parentName:"ul"},"Esto significa que el valor final del contador es predecible y siempre igual a la suma de los incrementos llevados por ambas tareas, que es 2,000,000."),(0,i.yg)("li",{parentName:"ul"},"Tenga en cuenta que el valor final del contador es siempre 2,000,000. Sin embargo, el valor inmediato (1,992,352) puede variar porque el programa se ejecuta simult\xe1neamente, con dos subprocesos compitiendo para incrementar la variable del contador.")),(0,i.yg)("h4",{id:"mejores-pr\xe1cticas"},"Mejores pr\xe1cticas"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Las siguientes son algunas de las mejores pr\xe1cticas al utilizar la declaraci\xf3n lock de C#:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Mantenga el bloque lock lo m\xe1s peque\xf1o posible para minimizar el tiempo que otros subprocesos tienen que esperar hasta el bloqueo. Si un bloque  lock tarda mucho en ejecutarse, puede provocar contenci\xf3n entre subprocesos y reducir el rendimiento de la aplicaci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"Evite los bloqueos anidados porque pueden provocar un punto muerto . Los interbloqueos ocurren cuando varios subprocesos intentan adquirir bloqueos en un orden diferente."),(0,i.yg)("li",{parentName:"ul"},"Utilice try...finally en el bloque para liberar el bloqueo correctamente cuando se produzca una excepci\xf3n en el bloque lock. Adem\xe1s, garantiza que otros subprocesos no se bloqueen indefinidamente."),(0,i.yg)("li",{parentName:"ul"},"Considere el uso de mecanismos de sincronizaci\xf3n alternativos como SemaphoreSlimy y ReaderWriterLockSlim porque pueden proporcionar un mejor rendimiento y un control m\xe1s detallado sobre la concurrencia.   ")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://code-maze.com/csharp-volatile-interlocked-lock/"},"Synchronization Mechanisms \u2013 Volatile vs Interlocked vs lock in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.csharptutorial.net/csharp-concurrency/csharp-lock/"},"C# Lock")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.delftstack.com/es/howto/csharp/lock-statement-in-csharp/"},"Declaraci\xf3n de lock en C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/lock"},"lock statement - ensure exclusive access to a shared resource")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/statements/lock"},"instrucci\xf3n lock: aseg\xfarese del acceso exclusivo a un recurso compartido")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.section.io/engineering-education/using-c-sharp-to-demonstrate-lock-in-thread/"},"Using C# to Demonstrate Lock in Thread")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://robertomiguelz.blogspot.com/2021/05/lock-en-c-manejo-de-multiconcurrencia.html"},"Lock en C#. Manejo de multiconcurrencia.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/1d42da/thread-locking-in-C-Sharp/"},"\tThread Locking In C#"))))),(0,i.yg)("h2",{id:"monitor"},"Monitor"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Monitor es similar a lock, pero la clase monitor proporciona m\xe1s control sobre la sincronizaci\xf3n de varios subprocesos que intentan acceder al mismo bloque de c\xf3digo."),(0,i.yg)("li",{parentName:"ul"},"Al utilizar un monitor, se puede garantizar que ning\xfan otro hilo pueda acceder a una secci\xf3n del c\xf3digo de la aplicaci\xf3n que est\xe1 ejecutando el propietario del bloqueo, a menos que el otro hilo est\xe9 ejecutando el c\xf3digo utilizando un objeto bloqueo diferente."),(0,i.yg)("li",{parentName:"ul"},"La clase Monitor tiene los siguientes m\xe9todos para sincronizar el acceso a una regi\xf3n de c\xf3digo tomando y liberando un bloqueo:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Enter(): Cuando invocamos el m\xe9todo Enter de la clase Monitor, \xe9ste adquiere un bloqueo exclusivo sobre el objeto especificado. Esto tambi\xe9n marca el comienzo de una secci\xf3n cr\xedtica o el comienzo de un recurso compartido."),(0,i.yg)("li",{parentName:"ul"},"Exit(): cuando se invoca el m\xe9todo Exit de la clase Monitor, libera el bloqueo en el objeto especificado. Esto tambi\xe9n marca el final de una secci\xf3n cr\xedtica o el final del recurso compartido protegido por el objeto bloqueado."),(0,i.yg)("li",{parentName:"ul"},"Pulse(): Cuando se invoca el m\xe9todo Pulse de la clase Monitor, env\xeda una se\xf1al a un hilo en la cola de espera de un cambio en el estado del objeto bloqueado."),(0,i.yg)("li",{parentName:"ul"},"Wait(): cuando se invoca el m\xe9todo Wait de la clase Monitor, libera el bloqueo de un objeto y bloquea el hilo actual hasta que vuelve a adquirir el bloqueo."),(0,i.yg)("li",{parentName:"ul"},"PulseAll(): Cuando se invoca el m\xe9todo PulseAll de la clase Monitor, env\xeda se\xf1ales a todos los subprocesos en espera de un cambio en el estado del objeto bloqueado."),(0,i.yg)("li",{parentName:"ul"},"TryEnter():  cuando invocamos el m\xe9todo TryEnter de la clase Monitor, intenta adquirir un bloqueo exclusivo en el objeto especificado.")))),(0,i.yg)("h4",{id:"ejemplo-para-comprender-la-clase-monitor-en-c-para-proteger-los-recursos-compartidos-del-acceso-simult\xe1neo"},"Ejemplo para comprender la clase Monitor en C# para proteger los recursos compartidos del acceso simult\xe1neo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El siguiente c\xf3digo es la sintaxis para usar los m\xe9todos Enter y Exit de la clase Monitor para proteger un recurso compartido en un entorno multiproceso del acceso simult\xe1neo en C#. Todos los m\xe9todos de la clase Monitor son m\xe9todos est\xe1ticos. Entonces, puede ver aqu\xed que estamos accediendo a los m\xe9todos Enter y Exit usando el nombre de clase, es decir, Monitor:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Monitor-Class-in-C-Multithreading.jpg?ezimgfmt=ng:webp/ngcb1",alt:"codigo"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En el siguiente ejemplo, tenemos un recurso compartido y accedemos a ese recurso simult\xe1neamente mediante tres subprocesos diferentes. Luego utilizamos los m\xe9todos de entrada y salida de la clase Monitor para proteger el c\xf3digo de la secci\xf3n critica. En este caso, los tres subprocesos intentar\xe1n adquirir un bloqueo exclusivo, pero en un momento dado, solo un subproceso obtiene un bloqueo exclusivo y entrar\xe1 en la secci\xf3n cr\xedtica y todos los dem\xe1s subprocesos esperar\xe1n hasta que el subproceso libere el bloqueo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nnamespace MonitorDemo\n{\n    class Program\n    {\n        private static readonly object lockPrintNumbers = new object();\n\n        public static void PrintNumbers()\n        {\n            Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");\n            \n            try\n            {\n                Monitor.Enter(lockPrintNumbers);\n                Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");\n                for (int i = 0; i < 5; i++)\n                {\n                    Thread.Sleep(100);\n                    Console.Write(i + ",");\n                }\n                Console.WriteLine();\n            }\n            finally\n            {\n                Monitor.Exit(lockPrintNumbers);\n                Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Thread[] Threads = new Thread[3];\n            for (int i = 0; i < 3; i++)\n            {\n                Threads[i] = new Thread(PrintNumbers)\n                {\n                    Name = "Child Thread " + i\n                };\n            }\n\n            foreach (Thread t in Threads)\n            {\n                t.Start();\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n')),(0,i.yg)("h4",{id:"c\xf3mo-funciona-la-clase-monitor-en-c"},"\xbfC\xf3mo funciona la clase Monitor en C#?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La clase Monitor en C# proporciona un mecanismo de sincronizaci\xf3n que permite que solo un subproceso acceda al c\xf3digo de la secci\xf3n cr\xedtica a la vez para evitar la condici\xf3n de carrera. Todos los dem\xe1s subprocesos tienen que esperar y detener la ejecuci\xf3n hasta que se libere el objeto bloqueado."),(0,i.yg)("li",{parentName:"ul"},"Para comprender c\xf3mo funciona la clase Monitor en C#, consulte el siguiente diagrama. Como se muestra en la imagen a continuaci\xf3n, tan pronto como un subproceso ejecute el m\xe9todo Enter de la clase Monitor, estar\xe1 en la cola Ready y, de la misma manera, muchos subprocesos pueden estar all\xed en la cola Ready. Luego, uno de los subprocesos de la cola lista adquirir\xe1 un bloqueo exclusivo en el objeto, ingresar\xe1 dentro de la secci\xf3n cr\xedtica y ejecutar\xe1 el c\xf3digo, y en ese momento, ning\xfan otro subproceso podr\xe1 tener la oportunidad de ingresar a la secci\xf3n cr\xedtica. Y luego, cuando ejecutamos el m\xe9todo Exit de la clase Monitor, el hilo que se est\xe1 ejecutando actualmente se mover\xe1 a la cola de espera y enviar\xe1 una se\xf1al a los hilos que est\xe1n en la cola Ready. y uno de los subprocesos de la cola Listo adquirir\xe1 el bloqueo, ingresar\xe1 a la secci\xf3n Cr\xedtica y comenzar\xe1 a ejecutar el c\xf3digo de la Secci\xf3n Cr\xedtica. As\xed es como funciona la clase Monitor en C#:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Monitor-Class-in-C.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Cola"})),(0,i.yg)("h4",{id:"m\xe9todo-monitorenterlockobject-ref-islocktaken-en-c"},"M\xe9todo Monitor.Enter(lockObject, ref IslockTaken) en C#:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Entendamos la otra versi\xf3n sobrecargada del m\xe9todo Enter. "),(0,i.yg)("li",{parentName:"ul"},"Monitor.Enter(lockObject, ref IslockTaken) adquiere un bloqueo exclusivo en el objeto especificado. Luego establece autom\xe1ticamente un valor que indica si el bloqueo se realiz\xf3 o no."),(0,i.yg)("li",{parentName:"ul"},"El segundo par\xe1metro, que es un par\xe1metro booleano, devuelve verdadero si se adquiere el bloqueo; de lo contrario, devuelve falso. La sintaxis para utilizar esta versi\xf3n sobrecargada se proporciona a continuaci\xf3n:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Monitor.EnterlockObject-ref-IslockTaken-Method-in-C-1.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Metodo enter"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El siguiente ejemplo muestra c\xf3mo utilizar el m\xe9todo Enter(lockObject, ref IslockTaken) de la clase Monitor en C#. El siguiente ejemplo es el mismo que el ejemplo anterior excepto que aqu\xed estamos usando la versi\xf3n sobrecargada del m\xe9todo Enter que toma dos par\xe1metros. El segundo par\xe1metro booleano especifica si el hilo adquiere un bloqueo o no, true indica que adquiere un bloqueo en el objeto y false indica que no adquiere un bloqueo en el objeto y nuevamente en el bloque finalmente estamos comprobando el valor booleano y en consecuencia, estamos liberando el bloqueo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nnamespace MonitorDemo\n{\n    class Program\n    {\n        private static readonly object lockPrintNumberst = new object();\n\n        public static void PrintNumbers()\n        {\n            Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");\n            bool IsLockTaken = false;\n            \n            try\n            {\n                Monitor.Enter(lockPrintNumberst, ref IsLockTaken);\n                if(IsLockTaken)\n                {\n                    Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");\n                    for (int i = 0; i < 5; i++)\n                    {\n                        Thread.Sleep(100);\n                        Console.Write(i + ",");\n                    }\n                    Console.WriteLine();\n                }\n            }\n            finally\n            {\n                if (IsLockTaken)\n                {\n                    Monitor.Exit(lockPrintNumberst);\n                    Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");\n                }\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Thread[] Threads = new Thread[3];\n            for (int i = 0; i < 3; i++)\n            {\n                Threads[i] = new Thread(PrintNumbers)\n                {\n                    Name = "Child Thread " + i\n                };\n            }\n\n            foreach (Thread t in Threads)\n            {\n                t.Start();\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n')),(0,i.yg)("h4",{id:"ejemplo-para-comprender-el-m\xe9todo-tryenterobject-timespan-boolean-de-la-clase-monitor-en-c"},"Ejemplo para comprender el m\xe9todo TryEnter(Object, TimeSpan, Boolean) de la clase Monitor en C#"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Este m\xe9todo intenta, durante un per\xedodo de tiempo espec\xedfico, adquirir un bloqueo exclusivo en el objeto especificado y establece autom\xe1ticamente un valor que indica si el bloqueo se tom\xf3 o no. La sintaxis se proporciona a continuaci\xf3n para utilizar el m\xe9todo TryEnter(Object, TimeSpan, Boolean) de la clase Monitor en C#:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/TryEnterObject-TimeSpan-Boolean-Method-of-Monitor-Class-in-C.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Metodo EntryEnter"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Para una mejor comprensi\xf3n, eche un vistazo al siguiente ejemplo que muestra c\xf3mo utilizar el m\xe9todo TryEnter(Object, TimeSpan, Boolean) de la clase Monitor en C#. En el siguiente ejemplo, hemos especificado el tiempo de espera en 1000 milisegundos o puede decir 1 segundo. Si dentro de 1 segundo el hilo no adquiere el bloqueo, entonces no ingresar\xe1 a la secci\xf3n cr\xedtica :")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\n\nnamespace MonitorDemo\n{\n    class Program\n    {\n        private static readonly object lockPrintNumbers = new object();\n\n        public static void PrintNumbers()\n        {\n            TimeSpan timeout = TimeSpan.FromMilliseconds(1000);\n            bool lockTaken = false;\n\n            try\n            {\n                Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");\n                Monitor.TryEnter(lockPrintNumbers, timeout, ref lockTaken);\n                if (lockTaken)\n                {\n                    Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");\n                    for (int i = 0; i < 5; i++)\n                    {\n                        Thread.Sleep(100);\n                        Console.Write(i + ",");\n                    }\n                    Console.WriteLine();\n                }\n                else\n                {\n                    // El lock was no fue adquirido.\n                    Console.WriteLine(Thread.CurrentThread.Name + " Lock was not acquired");\n                }\n            }\n            finally\n            {\n                // Para asegurarse de que se libere el bloqueo.\n                if (lockTaken)\n                {\n                    Monitor.Exit(lockPrintNumbers);\n                    Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");\n                }\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Thread[] Threads = new Thread[3];\n            for (int i = 0; i < 3; i++)\n            {\n                Threads[i] = new Thread(PrintNumbers)\n                {\n                    Name = "Child Thread " + i\n                };\n            }\n\n            foreach (Thread t in Threads)\n            {\n                t.Start();\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"La salida puede variar en su m\xe1quina. Como puede ver, los tres subprocesos intentan adquirir un bloqueo en el objeto en 1 segundo, y de tres subprocesos, dos adquieren un bloqueo exclusivo en el objeto, mientras que un subproceso no puede adquirir un bloqueo exclusivo y, por lo tanto, ese subproceso no entrar\xe1 en la secci\xf3n cr\xedtica.")))),(0,i.yg)("h4",{id:"ejemplo-para-comprender-los-m\xe9todos-wait-y-pulse-de-la-clase-monitor-en-c"},"Ejemplo para comprender los m\xe9todos Wait() y Pulse() de la clase Monitor en C#"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},'El m\xe9todo Wait() de la clase Monitor se utiliza para liberar el bloqueo de un objeto para permitir que otros subprocesos bloqueen y accedan al objeto. El hilo que llama espera mientras otro hilo accede al objeto. El hilo que llama a wait() permanece en una "cola de espera" , esperando a que alguien le notifique sobre un cambio en el objeto bloqueado para volver a la fila Ready.'),(0,i.yg)("li",{parentName:"ul"},"Pulse() se utiliza para notificar a los hilos en espera sobre cambios en el estado de un objeto bloqueado."),(0,i.yg)("li",{parentName:"ul"},"Entendamos esto con un ejemplo en tiempo real. Nuestro requisito comercial es imprimir la secuencia de n\xfameros pares e impares utilizando 2 subprocesos diferentes. Entonces, un hilo imprimir\xe1 los n\xfameros pares y otro hilo imprimir\xe1 los n\xfameros impares:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Hilo T1: 0,2,4,6,8\u2026"),(0,i.yg)("li",{parentName:"ul"},"Hilo T2: 1,3,5,7,9\u2026"),(0,i.yg)("li",{parentName:"ul"},"Salida: 0,1,2,3,4,5,6,7,8,9\u2026"))),(0,i.yg)("li",{parentName:"ul"},"Para resolver el problema anterior, usemos el mecanismo de se\xf1alizaci\xf3n usando los m\xe9todos Monitor Class Wait() y Pulse() en C#. "),(0,i.yg)("li",{parentName:"ul"},"En el siguiente ejemplo, utilizamos el m\xe9todo Monitor.Wait() para hacer que el subproceso est\xe9 en espera y el m\xe9todo Monitor.Pulse() para se\xf1alar otro subproceso. El proceso es el siguiente:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Primero, el hilo par comenzar\xe1 a imprimir el n\xfamero en la consola."),(0,i.yg)("li",{parentName:"ol"},"Luego, el hilo par indicar\xe1 al hilo impar que est\xe9 listo para imprimir el n\xfamero usando el m\xe9todo Monitor.Pulse()."),(0,i.yg)("li",{parentName:"ol"},"Luego, el subproceso del evento llamar\xe1 al m\xe9todo Monitor.Wait() que permitir\xe1 que el subproceso actual se bloquee y permitir\xe1 que el subproceso impar comience la ejecuci\xf3n."),(0,i.yg)("li",{parentName:"ol"},"Lo mismo tambi\xe9n har\xe1 el Odd Thread."),(0,i.yg)("li",{parentName:"ol"},"El hilo impar comenzar\xe1 a imprimir el n\xfamero en la consola."),(0,i.yg)("li",{parentName:"ol"},"Luego, el hilo impar indicar\xe1 al hilo par que est\xe9 listo para imprimir el n\xfamero usando el m\xe9todo Monitor.Pulse()."),(0,i.yg)("li",{parentName:"ol"},"Luego, el hilo impar llamar\xe1 al m\xe9todo Monitor.Wait() que permitir\xe1 que el hilo actual se bloquee y permitir\xe1 que el hilo par comience la ejecuci\xf3n."),(0,i.yg)("li",{parentName:"ol"},"El mismo proceso est\xe1 en marcha."))),(0,i.yg)("li",{parentName:"ul"},"Dado que los subprocesos pares e impares comparten la misma ventana de la consola para imprimir el n\xfamero, necesitamos bloquear la E/S de la consola. Queremos que la secuencia comience con el n\xfamero par, por lo que el hilo par debe ejecutarse primero. Una vez que iniciemos el hilo Par, luego debemos hacer una pausa por un momento antes de iniciar el hilo Impar usando el m\xe9todo Sleep() de la clase Thread en C# para evitar cualquier posibilidad de iniciar el hilo Impar primero:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\n\nnamespace odd_even_sequence\n{\n    class Program\n    {\n        //Hasta el l\xedmite de n\xfameros se imprimir\xe1n en la consola.\n        const int numberLimit = 20;\n\n        static readonly object _lockMonitor = new object();\n\n        static void Main(string[] args)\n        {\n            Thread EvenThread = new Thread(PrintEvenNumbers);\n            Thread OddThread = new Thread(PrintOddNumbers);\n\n            //Primero inicie el hilo par.\n            EvenThread.Start();\n\n            //Espera durante 10 ms para asegurarte de que se haya iniciado el hilo par.\n            //De lo contrario, un hilo extra\xf1o puede comenzar primero y dar como resultado una secuencia diferente.\n            Thread.Sleep(100);\n\n            //A continuaci\xf3n, inicie el hilo impar.\n            OddThread.Start();\n\n            //Espere a que se completen todos los hilos hijos.\n            OddThread.Join();\n            EvenThread.Join();\n\n            Console.WriteLine("\\nMain method completed");\n            Console.ReadKey();\n        }\n\n        //Funci\xf3n de impresi\xf3n de n\xfameros pares\n        static void PrintEvenNumbers()\n        {\n            try\n            {\n                //Implementar bloqueo ya que la consola se comparte entre dos subprocesos.\n                Monitor.Enter(_lockMonitor);\n                for (int i = 0; i <= numberLimit; i = i + 2)\n                {\n                    //Impresi\xf3n de n\xfameros pares en la consola\n                    Console.Write($"{i} ");\n\n                    //Notificar al hilo extra\xf1o que ya termin\xe9, t\xfa haces tu trabajo.\n                    //Notifica a un hilo en la cola de espera de un cambio en el\n                    //estado del objeto bloqueado.\n                    Monitor.Pulse(_lockMonitor);\n\n           \n\n                    bool isLast = false;\n                    if (i == numberLimit)\n                    {\n                        isLast = true;\n                    }\n\n                    if (!isLast)\n                    {\n                        //Esperar\xe9 aqu\xed hasta que Odd thread me notifique.\n                        //Libera el bloqueo de un objeto y bloquea el hilo actual.\n                        //hasta que recupere el  bloqueo.\n                        Monitor.Wait(_lockMonitor);\n                    }\n                }\n            }\n            finally\n            {\n                //Libera el bloqueo\n                Monitor.Exit(_lockMonitor);\n            }\n\n        }\n\n        //Funci\xf3n de impresi\xf3n de n\xfameros impares\n        static void PrintOddNumbers()\n        {\n            try\n            {\n                //Mantenga bloqueado ya que la consola se comparte entre dos subprocesos\n                Monitor.Enter(_lockMonitor);\n                for (int i = 1; i <= numberLimit; i = i + 2)\n                {\n                    //Imprimiendo los n\xfameros impares en la consola\n                    Console.Write($"{i} ");\n\n                    //Notificar a un hilo que ya termin\xe9, t\xfa haces tu trabajo.\n                    Monitor.Pulse(_lockMonitor);\n\n            \n\n                    bool isLast = false;\n                    if (i == numberLimit - 1)\n                    {\n                        isLast = true;\n                    }\n\n                    if (!isLast)\n                    {\n                        //Esperar\xe9 aqu\xed hasta que el hilo par me notifique\n                        Monitor.Wait(_lockMonitor);\n                    }\n                }\n            }\n            finally\n            {\n                //liberar bloqueo\n                Monitor.Exit(_lockMonitor);\n            }\n        }\n    }\n}\n\n')),(0,i.yg)("h4",{id:"importante"},"Importante"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La clase Monitor es una clase est\xe1tica y su instancia no se puede crear."),(0,i.yg)("li",{parentName:"ul"},"El objeto de clase Monitor utiliza los m\xe9todos Monitor.Enter, Monitor.TryEnter y Monitor.Exit. Una vez que haya bloqueado una regi\xf3n de c\xf3digo, puede usar los m\xe9todos Monitor.Wait, Monitor.Pulse y Monitor.PulseAll."),(0,i.yg)("li",{parentName:"ul"},"Est\xe1 asociado a un objeto bajo demanda."),(0,i.yg)("li",{parentName:"ul"},"No est\xe1 vinculado, lo que significa que se puede llamar directamente desde cualquier contexto.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/de41d6/monitor-and-lock-in-C-Sharp/"},"Monitor And Lock In C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.codeproject.com/Tips/788402/Monitor-and-Lock-in-Csharp"},"Monitor and Lock in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.monitor.tryenter?view=net-7.0"},"Monitor.TryEnter M\xe9todo")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.shekhali.com/c-monitor-class-in-multithreading-with-examples/"},"C# Monitor class in multithreading (with examples)")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.start?view=net-7.0"},"Thread.Start Method")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnettutorials.net/lesson/multithreading-using-monitor/"},"Monitor Class in C#"))))),(0,i.yg)("h2",{id:"semaphore"},"Semaphore"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El sem\xe1foro(Semaphore) de C# permite que solo un n\xfamero limitado de subprocesos entren en una secci\xf3n cr\xedtica."),(0,i.yg)("li",{parentName:"ul"},"Semaphore se usa principalmente en escenarios donde tenemos una cantidad limitada de recursos y tenemos que limitar la cantidad de subprocesos que pueden usarlo.")),(0,i.yg)("h4",{id:"c\xf3mo-funciona"},"\xbfC\xf3mo funciona?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los sem\xe1foros son variables Int32 almacenadas en los recursos de un sistema operativo. Cuando inicializamos el objeto sem\xe1foro, lo inicializamos con un n\xfamero. Este n\xfamero limita los subprocesos que pueden ingresar a la secci\xf3n cr\xedtica."),(0,i.yg)("li",{parentName:"ul"},"Cuando un hilo entra en una secci\xf3n cr\xedtica, disminuye la variable Int32 en 1 y cuando un hilo sale de una secci\xf3n cr\xedtica, aumenta la variable Int32 en 1."),(0,i.yg)("li",{parentName:"ul"},"Cuando la variable Int32 es 0, ning\xfan hilo puede entrar en una secci\xf3n cr\xedtica."),(0,i.yg)("li",{parentName:"ul"},"A continuaci\xf3n se muestra la sintaxis de la inicializaci\xf3n del sem\xe1foro de C#:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Semaphore semaphoreObject = new Semaphore(initialCount: 0, maximumCount: 5);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Inicializamos el objeto sem\xe1foro con dos par\xe1metros:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Recuento inicial"),(0,i.yg)("li",{parentName:"ol"},"Recuento m\xe1ximo")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El recuento m\xe1ximo define cu\xe1ntos subprocesos m\xe1ximos pueden ingresar en una secci\xf3n cr\xedtica. InitialCount establece el valor de la variable Int32. Por ejemplo, si establecemos el recuento m\xe1ximo de 3 y el recuento inicial de 0, eso significa que ya hay 3 subprocesos en la secci\xf3n cr\xedtica. Si configuramos el recuento m\xe1ximo de 3 y el recuento inicial de 3, eso significa que un m\xe1ximo de 3 subprocesos puede ingresar a una secci\xf3n cr\xedtica y no hay ning\xfan subproceso actualmente en la secci\xf3n cr\xedtica. ")),(0,i.yg)("h4",{id:"sem\xe1foro-usado-entre-m\xfaltiples-procesos"},"Sem\xe1foro usado entre m\xfaltiples procesos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Alternativamente, el sem\xe1foro tiene otro constructor que toma una cadena(string) adicional como par\xe1metro. Este par\xe1metro de cadena es una cadena \xfanica que se utiliza para usar el sem\xe1foro entre m\xfaltiples procesos."),(0,i.yg)("li",{parentName:"ul"},"A continuaci\xf3n se muestra la sintaxis para crear un sem\xe1foro:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'Semaphore semaphoreObject = new Semaphore(initialCount: 0, maximumCount: 5, name: "MyUniqueNameApp");\n')),(0,i.yg)("h4",{id:"m\xe9todo-waitone"},"M\xe9todo WaitOne"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los hilos pueden ingresar a la secci\xf3n cr\xedtica utilizando el m\xe9todo WaitOne. Si la variable Int32 mantenida por el sem\xe1foro es mayor que 0, entonces permite que ingrese el hilo de llamada."),(0,i.yg)("li",{parentName:"ul"},"A continuaci\xf3n, se muestra la sintaxis para llamar al m\xe9todo WaitOne:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"semaphoreObject.WaitOne();\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En otra sobrecarga del m\xe9todo WaitOne del sem\xe1foro, podemos pasar el intervalo de tiempo durante el cual un hilo puede esperar para recibir una se\xf1al del sem\xe1foro. Si el hilo no ha recibido la se\xf1al dentro de un tiempo interno especificado, devuelve   false:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"bool isSignalled = semaphoreObject.WaitOne(TimeSpan.FromSeconds(4));\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En el ejemplo anterior, si el hilo que llama no recibe la se\xf1al dentro de los 4 segundos especificados, devuelve false. Si recibe se\xf1al, devuelve true.")))),(0,i.yg)("h4",{id:"m\xe9todo-de-liberaci\xf3n"},"M\xe9todo de liberaci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando un hilo sale de la secci\xf3n cr\xedtica, debe llamar al m\xe9todo Release para incrementar el contador mantenido por el objeto sem\xe1foro. Permite que los hilos en espera entren en una secci\xf3n cr\xedtica:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"semaphoreObject.Release();\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"De forma predeterminada, el m\xe9todo Release solo incrementa el contador en 1. Eso significa que solo un hilo sale de la secci\xf3n cr\xedtica. Tambi\xe9n podemos pasar un par\xe1metro al m\xe9todo Release para definir cu\xe1ntos subprocesos se salen realmente:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"semaphoreObject.Release(3);\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En el c\xf3digo anterior, le pasamos el numero  3 como  par\xe1metro al m\xe9todo Release. Esto notificar\xe1 al objeto sem\xe1foro que 3 subprocesos en realidad est\xe1n saliendo de la secci\xf3n cr\xedtica. Entonces el objeto sem\xe1foro incrementa el contador en 3.")))),(0,i.yg)("h4",{id:"ejemplo"},"Ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En el siguiente ejemplo se muestra c\xf3mo utilizar el objeto sem\xe1foro con el objeto Impresora. Tenemos que limitar la cantidad de subprocesos que pueden usar simult\xe1neamente el objeto Impresora. Para eso utilizamos un objeto sem\xe1foro con un recuento m\xe1ximo de 3:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'class Program\n{\n    static void Main(string[] args)\n    {\n        Semaphore semaphoreObject = new Semaphore(initialCount: 3, maximumCount: 3, name: "PrinterApp");\n        Printer printerObject = new Printer();\n\n        for (int i = 0; i < 20; ++i)\n        {\n            int j = i;\n            Task.Factory.StartNew(() =>\n                {\n                    semaphoreObject.WaitOne();\n                    printerObject.Print(j);\n                    semaphoreObject.Release();\n                });\n        }\n        Console.ReadLine();\n    }\n}\n\nclass Printer\n{\n    public void Print(int documentToPrint)\n    {\n        Console.WriteLine("Printing document: " + documentToPrint);\n        Thread.Sleep(TimeSpan.FromSeconds(5));\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},'Inicializamos el objeto de sem\xe1foro con 3 recuentos iniciales y un m\xe1ximo de 3 y le damos un nombre \xfanico "PrinterApp". Iniciamos el bucle for con ejecuciones de 0 a 20. Iniciamos subprocesos usando Task.Factory.StartNew().'),(0,i.yg)("li",{parentName:"ul"},"Cada hilo llama al m\xe9todo WaitOne del objeto sem\xe1foro antes de usar el objeto Impresora. Esto limitar\xe1 la cantidad de subprocesos que utilizan el objeto Impresora. Despu\xe9s de usar el objeto de impresora, cada hilo llama al m\xe9todo Release para incrementar el contador del sem\xe1foro. Esto permite que m\xe1s hilos entren en una secci\xf3n cr\xedtica.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnetpattern.com/threading-semaphore"},"C# Semaphore")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.semaphore?view=net-7.0"},"Semaphore Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/1d42da/threading-with-semaphore-in-C-Sharp/"},"Threading with Semaphore in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnettutorials.net/lesson/semaphore-in-multithreading/"},"Semaphore Class in C#"))))),(0,i.yg)("h2",{id:"readerwriterlockslim"},"ReaderWriterLockSlim"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A veces, tienes varios subprocesos que leen desde un recurso compartido, pero solo unos pocos subprocesos que escriben en \xe9l. En este caso, el uso de la declaraci\xf3n lock puede disminuir el rendimiento de la aplicaci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"La raz\xf3n es que la declaraci\xf3n lock puede impedir que varios subprocesos lean el recurso compartido, aunque estos subprocesos no necesiten acceso exclusivo."),(0,i.yg)("li",{parentName:"ul"},"La clase ReaderWriterLockSlim permite que varios subprocesos lean el recurso compartido simult\xe1neamente, pero solo un subproceso escriba en \xe9l a la vez. Por lo tanto, ReaderWriterLockSlim puede ayudar a mejorar el rendimiento en comparaci\xf3n con la declaraci\xf3n lock."),(0,i.yg)("li",{parentName:"ul"},"ReaderWriterLockSlim tiene  dos tipos de bloqueo:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Bloqueo de  escritura"),(0,i.yg)("li",{parentName:"ul"},"Bloqueo de lectura"))),(0,i.yg)("li",{parentName:"ul"},"ReaderWriterLockSlim permite que varios subprocesos adquieran el bloqueo de lectura al mismo tiempo, siempre que ning\xfan subproceso adquiera el bloqueo de escritura."),(0,i.yg)("li",{parentName:"ul"},"Adem\xe1s, solo permite que un subproceso adquiera el bloqueo de escritura a la vez y bloquea a otros subprocesos para que no intenten adquirir el bloqueo de lectura o de escritura."),(0,i.yg)("li",{parentName:"ul"},"En la pr\xe1ctica, ReaderWriterLockSlim es \xfatil para escenarios en los que sus aplicaciones tienen varios lectores y menos escritores."),(0,i.yg)("li",{parentName:"ul"},"Debe usarlo cuando los beneficios del acceso concurrente sean mayores que el costo de adquirir y liberar el bloqueo.")),(0,i.yg)("h4",{id:"ejemplo-1"},"Ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El siguiente programa demuestra c\xf3mo utilizar el bjeto ReaderWriterLockSlimo para controlar el acceso simult\xe1neo a una variable compartida con cinco lectores y dos escritores:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using static System.Console;\n\nint counter = 0;\nReaderWriterLockSlim _lock = new();\n\nvoid Read()\n{\n    while (true)\n    {\n\n        try\n        {\n            _lock.EnterReadLock();\n            WriteLine($"R: Thread {Thread.CurrentThread.ManagedThreadId} is reading: {counter}");\n        }\n        finally\n        {\n            _lock.ExitReadLock();\n        }\n\n        Thread.Sleep(500);\n    }\n}\n\nvoid Write()\n{\n    while (true)\n    {\n        try\n        {\n            _lock.EnterWriteLock();\n            WriteLine($"W: Thread {Thread.CurrentThread.ManagedThreadId} is writing: {counter++}");\n        }\n        finally\n        {\n            _lock.ExitWriteLock();\n        }\n\n        Thread.Sleep(2000);\n    }\n}\n\n\n\nfor (int i = 0; i < 5; i++)\n{\n    new Thread(() => Read()).Start();\n}\n\n\nfor (int i = 0; i < 2; i++)\n{\n    new Thread(() => Write()).Start();\n}\n\n')),(0,i.yg)("h4",{id:"explicaci\xf3n-del-ejemplo"},"Explicaci\xf3n del ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Primero, declara una variable int counter:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"int counter = 0;\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En segundo lugar, cree un nuevo objeto  ReaderWriterLockSlim llamado _lock:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"ReaderWriterLockSlim _lock = new();\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En tercer lugar, define el  m\xe9todo  Reader() que adquiere un bloqueo de lectura en el objeto _lock llamando al  m\xe9todo  EnterReadLock() en el bloque try:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'void Read()\n{\n    while (true)\n    {\n\n        try\n        {\n            _lock.EnterReadLock();\n            WriteLine($"R: Thread {Thread.CurrentThread.ManagedThreadId} is reading: {counter}");\n        }\n        finally\n        {\n            _lock.ExitReadLock();\n        }\n\n        Thread.Sleep(500);\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo  Read() muestra el valor de la variable counter."),(0,i.yg)("li",{parentName:"ul"},"Adem\xe1s, libera el bloqueo de lectura del objeto _lock en el bloque  finally llamando al m\xe9todo ExitReadLock()."),(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo  Read() demora 500 milisegundos, que es medio segundo.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En cuarto lugar, define el m\xe9todo  Write para aumentar la variable compartida counter:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'void Write()\n{\n    while (true)\n    {\n        try\n        {\n            _lock.EnterWriteLock();\n            WriteLine($"W: Thread {Thread.CurrentThread.ManagedThreadId} is writing: {counter++}");\n        }\n        finally\n        {\n            _lock.ExitWriteLock();\n        }\n\n        Thread.Sleep(2000);\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo Write adquiere un bloqueo de escritura en el objeto _lock del bloque try llamando al m\xe9todo EnterWriteLock()."),(0,i.yg)("li",{parentName:"ul"},"Despu\xe9s de eso, aumenta  counter en uno y muestra el valor  counter en la consola. El m\xe9todo Write libera el bloqueo de escritura en el bloque  finally llamando al m\xe9todo ExitWriteLock()."),(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo Write tiene un retraso de 2000 milisegundos, que son 2 segundos.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Quinto, cree cinco hilos de lectura y dos hilos de escritura. Los subprocesos lectores ejecutan el m\xe9todo  Read mientras que los subprocesos escritores ejecutan el m\xe9todo Write:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"\nfor (int i = 0; i < 5; i++)\n{\n    new Thread(() => Read()).Start();\n}\n\n\nfor (int i = 0; i < 2; i++)\n{\n    new Thread(() => Write()).Start();\n}\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.csharptutorial.net/csharp-concurrency/csharp-readerwriterlockslim/"},"C# ReaderWriterLockSlim")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://code-maze.com/csharp-when-to-use-readerwriterlockslim-over-lock/"},"When to Use ReaderWriterLockSlim Over lock in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://subscription.packtpub.com/book/programming/9781785286650/1/ch01lvl1sec10/reader-writer-lock"},"Reader-writer lock")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/1d42da/readerwriterlockslim-class-in-C-Sharp-threading/"},"\tReaderWriterLockSlim Class in C# Threading")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim?view=net-7.0"},"ReaderWriterLockSlim Class")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.readerwriterlockslim?view=net-7.0"},"ReaderWriterLockSlim Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://doc.postsharp.net/threading/reader-writer-synchronized"},"Reader/Writer Synchronized Threading Model"))))),(0,i.yg)("h2",{id:"semaphoreslim"},"SemaphoreSlim"),(0,i.yg)("h4",{id:"concepto-sem\xe1foro"},"Concepto Sem\xe1foro"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Un sem\xe1foro es un mecanismo para limitar la cantidad de subprocesos que pueden acceder a un recurso compartido simult\xe1neamente."),(0,i.yg)("li",{parentName:"ul"},"El concepto de sem\xe1foro se basa en un contador que especifica la cantidad de recursos disponibles."),(0,i.yg)("li",{parentName:"ul"},"Para acceder al recurso compartido, un hilo necesita solicitar un permiso al sem\xe1foro."),(0,i.yg)("li",{parentName:"ul"},"Si el permiso est\xe1 disponible, el sem\xe1foro disminuir\xe1 el contador. Sin embargo, si el contador es cero, el sem\xe1foro se bloquear\xe1 hasta que est\xe9 disponible un permiso."),(0,i.yg)("li",{parentName:"ul"},"Una vez que el subproceso completa el procesamiento del recurso compartido, debe liberar el permiso al sem\xe1foro para que otros subprocesos puedan obtener el permiso. Cuando el hilo libera el permiso, el sem\xe1foro incrementa el contador."),(0,i.yg)("li",{parentName:"ul"},"C# tiene dos clases que implementan el concepto de sem\xe1foro: Semaphore y SemaphoreSlim."),(0,i.yg)("li",{parentName:"ul"},"La clase Semaphore ha estado disponible desde la primera versi\xf3n de .NET Framework.  La clase SemaphoreSlim es  m\xe1s reciente introducida en .NET Framework 4.0 y .NET core."),(0,i.yg)("li",{parentName:"ul"},"La clase SemaphoreSlim es una implementaci\xf3n ligera de la clase Semaphore. Es SemaphoreSlim m\xe1s r\xe1pido y m\xe1s eficiente en memoria que la clase Semaphore."),(0,i.yg)("li",{parentName:"ul"},"La clase SemaphoreSlim representa una alternativa ligera a Semaphore que limita la cantidad de subprocesos que pueden acceder a un recurso o grupo de recursos simult\xe1neamente.")),(0,i.yg)("h4",{id:"por-qu\xe9-necesitamos-semaphoreslim-si-ya-tenemos-lock-monitor-mutex-y-semaphore-en-c"},"\xbfPor qu\xe9 necesitamos SemaphoreSlim si ya tenemos Lock, Monitor, Mutex y Semaphore en C#?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Al igual que Lock , Monitor , Mutex y Semaphore , la clase SemaphoreSlim en C# tambi\xe9n se utiliza para proporcionar seguridad para subprocesos. El bloqueo(lock) y los monitores se utilizan b\xe1sicamente para proporcionar seguridad a los subprocesos internos, es decir, los subprocesos generados por la propia aplicaci\xf3n. Por otro lado, Mutex y Semaphore garantizan la seguridad de los subprocesos generados por aplicaciones externas, es decir, subprocesos externos. Al usar Mutex, solo un hilo externo puede acceder al c\xf3digo de nuestra aplicaci\xf3n en un momento dado. Y, si queremos tener m\xe1s control sobre la cantidad de subprocesos externos que pueden acceder al c\xf3digo de nuestra aplicaci\xf3n, entonces podemos usar Semaphore en C#."),(0,i.yg)("li",{parentName:"ul"},"Al usar Lock and Monitor, solo un hilo interno puede acceder al c\xf3digo de nuestra aplicaci\xf3n en un momento dado. Pero, si queremos tener m\xe1s control sobre la cantidad de subprocesos internos que pueden acceder al c\xf3digo de nuestra aplicaci\xf3n, entonces necesitamos usar la clase SemaphoreSlim en C#. ")),(0,i.yg)("h4",{id:"qu\xe9-es-la-clase-semaphoreslim-en-c"},"\xbfQu\xe9 es la clase SemaphoreSlim en C#?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Se recomienda la clase SemaphoreSlim en C# para la sincronizaci\xf3n dentro de una sola aplicaci\xf3n. "),(0,i.yg)("li",{parentName:"ul"},"Es un sem\xe1foro ligero que controla el acceso a un conjunto de recursos locales de su aplicaci\xf3n. Representa una alternativa ligera a Semaphore que limita la cantidad de subprocesos que pueden acceder a un recurso o grupo de recursos al mismo tiempo."),(0,i.yg)("li",{parentName:"ul"},"La clase SemaphoreSlim es liviana y m\xe1s r\xe1pida que Semaphore, ya que se limita a un solo proceso. "),(0,i.yg)("li",{parentName:"ul"},"El objeto SemaphoreSlim se utiliza para controlar el acceso a un recurso, como llamar a otra API o limitar las operaciones de E/S simult\xe1neamente para evitar problemas innecesarios de red/hardware."),(0,i.yg)("li",{parentName:"ul"},'La clase SemaphoreSlim es la alternativa ligera a Semaphore(nota "Slim"en el nombre). Al crear  una instancia de un nuevo objeto SemaphoreSlim, creamos un sem\xe1foro local. La localidad del sem\xe1foro indica que solo controla el acceso de otros subprocesos o procesos dentro de la aplicaci\xf3n')),(0,i.yg)("h4",{id:"c\xf3mo-utilizar-la-clase-semaphoreslim"},"C\xf3mo utilizar la clase SemaphoreSlim"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Primero, crea un objeto SemaphoreSlim y pasa el n\xfamero inicial de permisos a su constructor:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"SemaphoreSlim semaphore = new(3);\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este ejemplo, el objeto sem\xe1foro tiene un n\xfamero inicial de 3. Significa que hasta tres subprocesos pueden acceder a recursos compartidos simult\xe1neamente.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En segundo lugar, llame al m\xe9todo  WaitAsync() del objeto sem\xe1foro para solicitar un permiso:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"await semaphore.WaitAsync();\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo  WaitAsync() devuelve un objeto Task que espera a que se conceda el permiso.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En tercer lugar, llame al m\xe9todo  Release() del objeto sem\xe1foro para liberar el permiso una vez que haya completado el acceso al recurso compartido:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"semaphore.Release();\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Es una buena pr\xe1ctica utilizar el bloque  try...finally para garantizar que siempre se llame al m\xe9todo Release()  incluso si se genera una excepci\xf3n al acceder al recurso compartido:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"await semaphore.WaitAsync();\n\ntry\n{\n    // Accede al recurso compartido\n}\nfinally\n{\n    semaphore.Release();\n}\n\n")),(0,i.yg)("h4",{id:"ejemplo-2"},"Ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El siguiente ejemplo demuestra c\xf3mo utilizar la clase  SemaphoreSlim para permitir que un n\xfamero limitado de tareas puedan acceder al recurso compartido simult\xe1neamente:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using static System.Console; \n\nSemaphoreSlim semaphore = new(3);\nint amount = 0;\n\nasync Task AccessAsync(int id)\n{\n    WriteLine($"Task {id} is waiting to access the amount.");\n    await semaphore.WaitAsync();\n\n    try\n    {\n        WriteLine($"Task {id} is now accessing the amount.");\n\n\n        // Simular alg\xfan trabajo\n        await Task.Delay(TimeSpan.FromSeconds(1));\n        \n        // Aumentar el contador\n        Interlocked.Increment(ref amount);\n\n\n        // Complet\xf3 el trabajo\n        WriteLine($"Task {id} has completed accessing the amount {amount}");\n    }\n    finally\n    {\n        semaphore.Release();\n    }\n}\n\n\n// Inicie 10 tareas para acceder a "amount" al mismo tiempo.\nvar  tasks = new List<Task>();\n\nfor (int i = 1; i <= 10; i++)\n{\n    tasks.Add(AccessAsync(i));\n}\n\n// Esperar a que se completen todas las tareas\nawait Task.WhenAll(tasks);\n\nWriteLine("All tasks completed.");\nReadLine();\n\n')),(0,i.yg)("h4",{id:"c\xf3mo-funciona-1"},"C\xf3mo funciona"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Primero, cree un objeto SemaphoreSlim que permite que hasta tres tareas accedan al recurso compartido al mismo tiempo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"SemaphoreSlim semaphore = new(3);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A continuaci\xf3n, declare la variable  amount que act\xfaa como recurso compartido:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"int amount = 0;\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Luego, defini un m\xe9todo asincr\xf3nico AccessAsync que tome un par\xe1metro int id:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'async Task AccessAsync(int id)\n{\n    WriteLine($"Task {id} is waiting to access the amount.");\n    await semaphore.WaitAsync();\n\n    try\n    {\n        WriteLine($"Task {id} is now accessing the amount.");\n\n\n       \n        await Task.Delay(TimeSpan.FromSeconds(1));\n        \n     \n        Interlocked.Increment(ref amount);\n\n\n       \n        WriteLine($"Task {id} has completed accessing the amount {amount}");\n    }\n    finally\n    {\n        semaphore.Release();\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo  AccessAsync() simula el acceso a la variable compartida amount utilizando el objeto sem\xe1foro."),(0,i.yg)("li",{parentName:"ul"},"La llamada al m\xe9todo WaitAsync() del objeto sem\xe1foro es  para esperar a que haya un permiso disponible, incrementa la variable amount usando el m\xe9todo  Increment() de la clase Interlocked y devuelve el permiso al sem\xe1foro usando el m\xe9todo  Release() del objeto sem\xe1foro."),(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo  AccessAsync() tambi\xe9n escribe algunos mensajes en la consola para indicar el inicio y el final de la tarea.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Despu\xe9s de eso, cree diez tareas que ejecuten el m\xe9todo  AccessAsync y espere a que se completen usando el m\xe9todo  Task.WhenAll():")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"\nvar  tasks = new List<Task>();\n\nfor (int i = 1; i <= 10; i++)\n{\n    tasks.Add(AccessAsync(i));\n}\n\n\nawait Task.WhenAll(tasks);\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Finalmente, escribi un mensaje a la consola para notificar la finalizaci\xf3n de todas las tareas y espere a que el usuario presione una tecla antes de finalizar el programa:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'WriteLine("All tasks completed.");\nReadLine();\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.csharptutorial.net/csharp-concurrency/csharp-semaphoreslim/"},"C# SemaphoreSlim")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnettutorials.net/lesson/semaphoreslim-class-in-csharp/"},"SemaphoreSlim Class in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/article/understanding-semaphore-in-net-core/"},"\tUnderstanding Semaphore in .NET Core")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.semaphoreslim?view=net-7.0"},"SemaphoreSlim Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim?view=net-7.0"},"SemaphoreSlim Class")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.interlocked?view=net-7.0"},"Interlocked Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://aaronbos.dev/posts/how-to-use-semaphoreslim-csharp"},"How to Use SemaphoreSlim in C#"))))),(0,i.yg)("h2",{id:"mutex"},"Mutex"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Mutex en C# sirve para proteger recursos compartidos en subprocesos m\xfaltiples.")),(0,i.yg)("h4",{id:"por-qu\xe9-mutex-si-ya-tenemos-lock-and-monitor-para-la-seguridad-de-subprocesos"},"\xbfPor qu\xe9 Mutex si ya tenemos Lock and Monitor para la seguridad de subprocesos?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Mutex tambi\xe9n nos ayuda a garantizar que nuestro c\xf3digo sea seguro para subprocesos. Eso significa que cuando ejecutamos nuestro c\xf3digo en un entorno de subprocesos m\xfaltiples no terminamos con resultados inconsistentes. "),(0,i.yg)("li",{parentName:"ul"},"Los bloqueos y monitores garantizan la seguridad de los subprocesos que est\xe1n en proceso, es decir, los subprocesos generados por la propia aplicaci\xf3n, es decir, subprocesos internos. Pero si los subprocesos provienen de OutProcess, es decir, de aplicaciones externas, Locks and Monitors no tiene control sobre ellos.  "),(0,i.yg)("li",{parentName:"ul"},"Mutex garantiza la seguridad de los subprocesos para los subprocesos que est\xe1n fuera de proceso, es decir, los subprocesos generados por las aplicaciones externas, es decir, subprocesos externos."),(0,i.yg)("li",{parentName:"ul"},"Primero comprendamos qu\xe9 es el proceso externo o los subprocesos externos y luego entenderemos Mutex en C#. Primero creemos una aplicaci\xf3n de consola y luego copiemos y peguemos el siguiente c\xf3digo en ella:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nnamespace MutexDemo {\n  class Program {\n    static void Main(string[] args) {\n      Console.WriteLine("Application Is Running.......");\n      Console.ReadKey();\n    }\n  }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora, cree el proyecto y vaya al directorio bin\\Debug del proyecto y all\xed encontrar\xe1 el archivo EXE de la aplicaci\xf3n:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/External-Threads-in-C.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Archivo exe"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando hace doble clic en el archivo EXE de la aplicaci\xf3n, un hilo externo ejecutar\xe1 el c\xf3digo de la aplicaci\xf3n. Y ahora, si hace doble clic varias veces, cada vez se crear\xe1 un nuevo hilo externo y se ejecutar\xe1 el c\xf3digo de nuestra aplicaci\xf3n como se muestra en la imagen a continuaci\xf3n. Hago doble clic en el EXE tres veces, por lo que tres subprocesos externos acceden a nuestra aplicaci\xf3n al mismo tiempo:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/External-Threads-Executing-our-Application-Code.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Ejecuci\xf3n"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora, reescribamos el ejemplo anterior usando la clase C# Mutex y veamos qu\xe9 sucede cuando intentamos acceder al c\xf3digo de la aplicaci\xf3n varias veces desde afuera usando subprocesos externos."),(0,i.yg)("li",{parentName:"ul"},"Modifique el c\xf3digo del archivo de clase Program.cs de la siguiente manera. Entonces, cuando un hilo externo accede a nuestro c\xf3digo, ning\xfan hilo externo puede acceder al c\xf3digo. El siguiente ejemplo hace exactamente lo mismo usando la clase C# Mutex. Este es uno de los casos de uso de Mutex en C#:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nnamespace MutexDemo {\n  class Program {\n    static void Main(string[] args) {\n      using(Mutex mutex = new Mutex(false, "MutexDemo")) {\n        //Comprobar si se est\xe1 ejecutando otro hilo externo\n        if (!mutex.WaitOne(5000, false)) {\n          Console.WriteLine("An Instance of the Application is Already Running");\n          Console.ReadKey();\n          return;\n        }\n        Console.WriteLine("Application Is Running.......");\n        Console.ReadKey();\n      }\n    }\n  }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora cierre todas las instancias que se est\xe9n ejecutando. Luego cree el proyecto y vaya nuevamente al directorio bin\\Debug de proyectos y nuevamente haga clic en el archivo Exe por primera vez. Obtendr\xe1 el siguiente resultado:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Understanding-Mutex-in-C.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Resultado"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora, vuelva a hacer clic en el archivo EXE. Esta vez esperar\xe1 5 segundos y luego te dar\xe1 el siguiente mensaje. Esto garantiza que solo un hilo externo pueda acceder al c\xf3digo de nuestra aplicaci\xf3n en un momento dado:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Mutex-in-C-with-Examples.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Segundo Resultado"})),(0,i.yg)("h4",{id:"qu\xe9-es-la-clase-mutex-en-c"},"\xbfQu\xe9 es la clase Mutex en C#?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Mutex funciona como un candado(lock), es decir, usa un bloqueo exclusivo en un recurso compartido que utilizan varios subprocesos de manera paralela."),(0,i.yg)("li",{parentName:"ul"},"Mutex funciona en m\xfaltiples procesos."),(0,i.yg)("li",{parentName:"ul"},"El bloqueo exclusivo se utiliza b\xe1sicamente para garantizar que, en un momento dado, solo un subproceso pueda ingresar a la secci\xf3n cr\xedtica."),(0,i.yg)("li",{parentName:"ul"},"Cuando dos o m\xe1s subprocesos necesitan acceder a un recurso compartido al mismo tiempo, el sistema necesita un mecanismo de sincronizaci\xf3n para garantizar que solo un subproceso a la vez utilice el recurso. Mutex es un mecanismo de sincronizaci\xf3n que otorga acceso exclusivo al recurso compartido a un solo hilo externo. Si un hilo adquiere un mutex, el segundo hilo que quiere adquirir ese mutex se suspende hasta que el primer hilo libere el mutex. ")),(0,i.yg)("h4",{id:"constructores"},"Constructores"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La clase Mutex en C# proporciona los siguientes cuatro constructores que podemos usar para crear una instancia de la clase Mutex.",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Mutex() : Inicializa una nueva instancia de la clase Mutex con propiedades predeterminadas."),(0,i.yg)("li",{parentName:"ol"},"Mutex (bool inicialmenteOwned) : inicializa una nueva instancia de la clase Mutex con un valor booleano que indica si el hilo que llama debe tener la propiedad inicial(bloqueo) del mutex. Si es true, el hilo va a intentar obtener el \u201cbloqueo\u201d que creamos al instanciar el objeto Mutex."),(0,i.yg)("li",{parentName:"ol"},"Mutex (bool inicialmenteOwned, nombre de cadena) : inicializa una nueva instancia de la clase System.Threading.Mutex con un valor booleano que indica si el subproceso que llama debe tener la propiedad inicial(bloqueo) del mutex y una cadena que es el nombre del mutex. "),(0,i.yg)("li",{parentName:"ol"},"Mutex (bool inicialmenteOwned, nombre de cadena, out bool creado Nuevo) : inicializa una nueva instancia de la clase System.Threading.Mutex con un valor booleano que indica si el hilo que llama debe tener la propiedad inicial(bloqueo) del mutex, una cadena que es el nombre. del mutex y un valor booleano que indica si al subproceso que realiza la llamada se le concedi\xf3 la propiedad inicial(bloqueo) del mutex.")))),(0,i.yg)("h4",{id:"m\xe9todos"},"M\xe9todos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La clase Mutex en C# proporciona los siguientes m\xe9todos (entre muchos otros):",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"OpenExisting (nombre de cadena): este m\xe9todo se utiliza para abrir el mutex con un nombre especificado si ya existe. Devuelve un objeto que representa el mutex del sistema nombrado. Aqu\xed, el nombre del par\xe1metro especifica el nombre del mutex del sistema que se abrir\xe1. Lanzar\xe1 ArgumentException si el nombre es una cadena vac\xeda. -o- el nombre tiene m\xe1s de 260 caracteres. Lanzar\xe1 ArgumentNullException si el nombre es nulo."),(0,i.yg)("li",{parentName:"ul"},"TryOpenExisting (nombre de cadena, resultado): este m\xe9todo se utiliza para abrir el mutex con nombre especificado, si ya existe, y devuelve un valor que indica si la operaci\xf3n se realiz\xf3 correctamente. Aqu\xed, el nombre del par\xe1metro especifica el nombre del mutex del sistema que se abrir\xe1. Cuando este m\xe9todo retorna algo, el resultado contiene un objeto Mutex que representa el mutex nombrado si la llamada se realiz\xf3 correctamente, o nulo si la llamada fall\xf3. Este par\xe1metro se trata como no inicializado. Devuelve verdadero si el mutex nombrado se abri\xf3 correctamente; en caso contrario, falso."),(0,i.yg)("li",{parentName:"ul"},"ReleaseMutex(): este m\xe9todo se utiliza para liberar  el Mutex.")))),(0,i.yg)("h4",{id:"ejemplo-para-comprender-mutex-en-c-para-proteger-recursos-compartidos-en-subprocesos-m\xfaltiples"},"Ejemplo para comprender Mutex en C# para proteger recursos compartidos en subprocesos m\xfaltiples"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El siguiente ejemplo muestra c\xf3mo se utiliza un objeto Mutex local para sincronizar el acceso a un recurso protegido. Debido a que cada subproceso que llama est\xe1 bloqueado hasta que adquiere la propiedad del mutex, debe llamar al m\xe9todo ReleaseMutex para liberar la propiedad del mutex. El c\xf3digo se explica por s\xed mismo. Entonces, lea las l\xedneas de comentarios:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\n\nnamespace MutexDemo\n{\n    class Program\n    {\n        private static Mutex mutex = new Mutex();\n\n        static void Main(string[] args)\n        {\n            //Crea m\xfaltiples hilos para entender Mutex\n            for (int i = 1; i <= 5; i++)\n            {\n                Thread threadObject = new Thread(MutexDemo)\n                {\n                    Name = "Thread " + i\n                };\n                threadObject.Start();\n            }\n            Console.ReadKey();\n        }\n\n        //M\xe9todo para implementar la sincronizaci\xf3n usando Mutex\n        static void MutexDemo()\n        {\n            Console.WriteLine(Thread.CurrentThread.Name + " Wants to Enter Critical Section for processing");\n            try\n            {\n                //Bloquea el hilo actual hasta que el m\xe9todo WaitOne actual reciba una se\xf1al.  \n                //Espere hasta que sea seguro ingresar.. \n                mutex.WaitOne();\n                Console.WriteLine("Success: " + Thread.CurrentThread.Name + " is Processing now");\n                Thread.Sleep(2000);\n                Console.WriteLine("Exit: " + Thread.CurrentThread.Name + " is Completed its task");\n            }\n            finally\n            {\n                //Llame al m\xe9todo ReleaseMutex para desbloquear y que otros hilos\n                //Que est\xe1n tratando de obtener la propiedad del mutex puedan ingresar  \n                mutex.ReleaseMutex();\n            }\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Se utiliza el metodo WaitOne() para obtener la propiedad(bloqueo) del Mutex."),(0,i.yg)("li",{parentName:"ul"},"El subproceso se suspende hasta poder adquirir el bloqueo.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En el siguiente ejemplo, cada subproceso llama al m\xe9todo WaitOne(Int32) para adquirir el mutex. Si transcurre el intervalo de tiempo de espera, el m\xe9todo devuelve false y el subproceso no adquiere el mutex ni obtiene acceso al recurso. El m\xe9todo ReleaseMutex lo llama \xfanicamente el subproceso que adquiere el mutex. En el siguiente ejemplo, llamamos al m\xe9todo Dispose desde el destructor:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\n\nnamespace MutexDemo\n{\n    class Program\n    {\n        private static Mutex mutex = new Mutex();\n\n        static void Main(string[] args)\n        {\n            //Crea m\xfaltiples hilos para entender Mutex\n            for (int i = 1; i <= 3; i++)\n            {\n                Thread threadObject = new Thread(MutexDemo)\n                {\n                    Name = "Thread " + i\n                };\n                threadObject.Start();\n            }\n            Console.ReadKey();\n        }\n\n        //M\xe9todo para implementar la sincronizaci\xf3n usando Mutex  \n        static void MutexDemo()\n        {\n            // Espere hasta que sea seguro ingresar y no ingrese si la solicitud caduca..\n            Console.WriteLine(Thread.CurrentThread.Name + " Wants to Enter Critical Section for processing");\n            if (mutex.WaitOne(1000))\n            {\n                try\n                {\n                    Console.WriteLine("Success: " + Thread.CurrentThread.Name + " is Processing now");\n\n                    Thread.Sleep(2000);\n\n                    Console.WriteLine("Exit: " + Thread.CurrentThread.Name + " is Completed its task");\n                }\n                finally\n                {\n                    //Llame al m\xe9todo ReleaseMutex para desbloquear y que otros hilos\n                    //que est\xe1n tratando de obtener la propiedad del mutex puedan ingresar\n                    mutex.ReleaseMutex();\n                    Console.WriteLine(Thread.CurrentThread.Name + " Has Released the mutex");\n                }\n            }\n            else\n            {\n                Console.WriteLine(Thread.CurrentThread.Name + " will not acquire the mutex");\n            }\n        }\n\n        ~Program()\n        {\n            mutex.Dispose();\n        }\n    }\n}\n\n')),(0,i.yg)("h4",{id:"ejemplo-de-m\xe9todo-openexisting-de-clase-mutex-en-c"},"Ejemplo de m\xe9todo OpenExisting de clase Mutex en C#"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En el siguiente ejemplo, utilizamos el m\xe9todo OpenExisting de la clase Mutex en C#. Si este m\xe9todo genera una excepci\xf3n, el Mutex  especificado no existe o es inaccesible. El m\xe9todo IsSingleInstance utiliza este comportamiento."),(0,i.yg)("li",{parentName:"ul"},"Primero, cree una aplicaci\xf3n de consola y copie y pegue el siguiente c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nnamespace MutexDemo\n{\n    class Program\n    {\n        static Mutex _mutex;\n        \n        static void Main()\n        {\n            //Si IsSingleInstance devuelve verdadero, contin\xfae con el programa; de lo contrario, salga del programa.\n            if (!IsSingleInstance())\n            {\n                Console.WriteLine("More than one instance"); // Salir del programa.\n            }\n            else\n            {\n                Console.WriteLine("One instance"); // Continuar con el programa.\n            }\n            // Mantente abierto.\n            Console.ReadLine();\n        }\n\n        static bool IsSingleInstance()\n        {\n            try\n            {\n                // Intente abrir Mutex existente.\n                //Si Mutex no se abre, se producir\xe1 una excepci\xf3n.\n                Mutex.OpenExisting("MyMutex");\n            }\n            catch\n            {\n                // Si se produjo una excepci\xf3n, no existe tal exclusi\xf3n mutua.\n                _mutex = new Mutex(true, "MyMutex");\n\n                // Solo una instancia.\n                return true;\n            }\n\n            // Mas de una instancia.\n            return false;\n        }\n    }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ahora, cree el proyecto y luego vaya al directorio bin\\Debug de proyectos y haga clic en el archivo EXE de la aplicaci\xf3n tres veces y obtendr\xe1 los siguientes resultados:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2019/07/Mutex.OpenExisting-Method-Example-in-C.jpg?ezimgfmt=ng:webp/ngcb1",alt:"Resultado"})),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Mutex solo permite que un hilo externo acceda al c\xf3digo de nuestra aplicaci\xf3n. Pero si queremos tener m\xe1s control sobre la cantidad de subprocesos externos para acceder al c\xf3digo de nuestra aplicaci\xf3n, entonces necesitamos usar la clase Semaphore en C#.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.threading.mutex?view=net-7.0"},"Mutex Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://forums.codeguru.com/showthread.php?389016-what-does-the-quot-initial-ownership-quot-parameter-do-in-mutex-constructor"},'what does the "initial ownership" parameter do in mutex constructor?')),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnettutorials.net/lesson/mutex-in-multithreading/"},"Mutex Class in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://code-maze.com/csharp-how-to-use-mutex-class/"},"How to Use Mutex in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://hdeleon.net/mutex-en-c-net/"},"Mutex en C# .NET")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/1d42da/threading-with-mutex/"},"\tThreading with Mutex"))))),(0,i.yg)("h2",{id:"atributo-synchronization"},"Atributo Synchronization"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Impone un dominio de sincronizaci\xf3n para el contexto (scope) actual y todos los contextos que compartan la misma instancia."),(0,i.yg)("li",{parentName:"ul"},"Realiza la misma funci\xf3n que Monitor, Lock , etc.")),(0,i.yg)("h4",{id:"problema-de-la-concurrencia"},"Problema de la concurrencia"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando crea una aplicaci\xf3n multiproceso, su programa debe garantizar que los datos compartidos est\xe9n protegidos de la posibilidad de que varios subprocesos interact\xfaen con su valor. \xbfQu\xe9 pasar\xeda si varios subprocesos accedieran a los datos en el mismo punto? El CLR puede suspender por un tiempo cualquier hilo que vaya a actualizar el valor o que est\xe9 en medio de actualizar el valor y al mismo tiempo un hilo llega a leer ese valor que no est\xe1 completamente actualizado, ese hilo est\xe1 leyendo datos incompletos/inestables."),(0,i.yg)("li",{parentName:"ul"},"Para ilustrar el problema de la concurrencia, escribamos una l\xednea de c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'class Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine("----Synchronnization of Threads-----");\n        Console.WriteLine("Main Thread {0}", Thread.CurrentThread.ManagedThreadId);\n        Printer p = new Printer();\n\n        Thread[] threads = new Thread[5];\n\n        //Cola de 5 hilos\n        for (int i = 0; i < 5; i++)\n        {\n            threads[i] = new Thread(new ThreadStart(p.PrintNumbersNonSync));\n        }\n        foreach (Thread t in threads)\n        {\n            t.Start();\n        }\n        Console.ReadLine();\n    }\n}\n\nclass Printer\n{\n    public void PrintNumbersNonSync()\n    {\n        Console.WriteLine(" ");\n        Console.WriteLine("Executing Thread {0}", Thread.CurrentThread.ManagedThreadId);\n        for (int i = 1; i <= 10; i++)\n        {\n            Console.Write(i + " ");\n        }\n    }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ejecute este programa varias veces y observe el resultado."),(0,i.yg)("li",{parentName:"ul"},"Salida 1:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://n7b3p4s2.stackpathcdn.com/UploadFile/vendettamit/synchronizing-threads-in-a-multithreaded-application-in-net-C-Sharp/Images/Multithrdng1.gif",alt:"Salida 1"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Salida 2:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://n7b3p4s2.stackpathcdn.com/UploadFile/vendettamit/synchronizing-threads-in-a-multithreaded-application-in-net-C-Sharp/Images/Multithrdng2.gif",alt:"Salida 2"})),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Como puede ver, todos los resultados variar\xe1n cada vez que ejecute el programa."),(0,i.yg)("li",{parentName:"ul"},"Lo que sucede aqu\xed es que todos los subprocesos comparten el mismo objeto de la clase Impresora e intentan ejecutar la misma funci\xf3n al mismo tiempo, por lo que cada vez los datos compartidos se actualizan aleatoriamente, lo cual es un estado inestable.")))),(0,i.yg)("h4",{id:"soluci\xf3n"},"Soluci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Para solucionar este problema, se puede usar Lock:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public void PrintNumbersSynchronized()\n{\n    //Hilo Synchronization \n    lock (this)\n    {\n        Console.WriteLine(" ");\n        Console.WriteLine("Executing Thread {0}", Thread.CurrentThread.ManagedThreadId);\n\n        for (int i = 1; i <= 10; i++)\n        {\n            Console.Write(i + " ");\n        }\n\n    }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Sin embargo, si est\xe1 bloqueando una regi\xf3n de c\xf3digo dentro de un miembro p\xfablico, es m\xe1s seguro (y la mejor pr\xe1ctica) declarar un  objeto privado para que sirva como token de bloqueo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'class Printer\n{\n    //  Token Synchronization\n    private Object ThreadLock = new object();\n\n    public void PrintNumbersSynchronized()\n    {\n        //Hilo Synchronization \n        lock (ThreadLock)\n        {\n            Console.WriteLine(" ");\n            Console.WriteLine("Executing Thread {0}", Thread.CurrentThread.ManagedThreadId);\n            for (int i = 1; i <= 10; i++)\n            {\n                Console.Write(i + " ");\n            }\n\n\n\n        }\n    }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Se puede solucionar con Monitor:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public void PrintNumbersSync()\n{\n    Monitor.Enter(ThreadLock);\n    try\n    {\n        Console.WriteLine(" ");\n        Console.WriteLine("Executing Thread {0}", Thread.CurrentThread.ManagedThreadId);\n        for (int i = 1; i <= 10; i++)\n        {\n            Console.Write(i + " ");\n        }\n    }\n    finally\n    {\n        Monitor.Exit(ThreadLock);\n    }\n}\n\n')),(0,i.yg)("h4",{id:"podemos-usar-el-atributo-synchronization"},"Podemos usar el atributo Synchronization"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El atributo  Synchronization  es miembro del espacio de nombres System.Runtime.Remoting.Contexts. "),(0,i.yg)("li",{parentName:"ul"},"En esencia, este atributo de nivel de clase, bloquea efectivamente todo el c\xf3digo de la instancia del objeto para la seguridad de los subprocesos. "),(0,i.yg)("li",{parentName:"ul"},"Adem\xe1s, debe derivar su clase de ContextBoundObject para mantener su objeto dentro de los l\xedmites contextuales."),(0,i.yg)("li",{parentName:"ul"},"Le indica al CLR que aplique el bloqueo autom\xe1ticamente."),(0,i.yg)("li",{parentName:"ul"},"Aqu\xed est\xe1 el c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'class Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine("----Synchronnization of Threads-----");\n        Console.WriteLine("Main Thread {0}", Thread.CurrentThread.ManagedThreadId);\n        Printer p = new Printer();\n        Thread[] threads = new Thread[5];\n\n        //Cola de 5 hilos\n        for (int i = 0; i < 5; i++)\n        {\n            threads[i] = new Thread(new ThreadStart(p.PrintNumbersNonSync));\n        }\n        foreach (Thread t in threads)\n        {\n            t.Start();\n        }\n\n        Console.ReadLine();\n    }\n}\n\n[Synchronization]\nclass Printer : ContextBoundObject\n{\n    public void PrintNumbersNonSync()\n    {\n        Console.WriteLine(" ");\n        Console.WriteLine("Executing Thread {0}", Thread.CurrentThread.ManagedThreadId);\n        for (int i = 1; i <= 10; i++)\n        {\n            Console.Write(i + " ");\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-warning alert alert--danger"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Este enfoque es una forma perezosa de escribir c\xf3digo seguro para subprocesos porque CLR puede bloquear datos confidenciales sin subprocesos y podr\xeda ser v\xedctima de Overclocking. As\xed que elija este enfoque con prudencia y cuidado.")))),(0,i.yg)("h4",{id:"ejemplo-3"},"Ejemplo"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nusing System.Runtime.Remoting.Contexts;\n \n[Synchronization]\npublic class AutoLock : ContextBoundObject\n{\n  public void Demo()\n  {\n    Console.Write ("Start...");\n    // Nosotros no nos podemos adelantar aqu\xed\n    // \xa1Gracias al bloqueo autom\xe1tico!\n    Thread.Sleep (1000); \n    Console.WriteLine ("end");     \n  } \n}\n \npublic class Test\n{\n  public static void Main()\n  {\n    AutoLock safeInstance = new AutoLock();\n    // Llamamos al mismo m\xe9todo tres veces\n    new Thread (safeInstance.Demo).Start();     \n    new Thread (safeInstance.Demo).Start();     \n    safeInstance.Demo();                        \n  }\n}\n\n')),(0,i.yg)("h4",{id:"explicaci\xf3n-del-ejemplo-1"},"Explicaci\xf3n del ejemplo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"CLR garantiza que solo un subproceso pueda ejecutar el c\xf3digo de la instancia safeInstance a la vez. "),(0,i.yg)("li",{parentName:"ul"},"Para ello, crea un \xfanico objeto de sincronizaci\xf3n y lo bloquea en cada llamada a cada uno de los m\xe9todos o propiedades de safeInstance. "),(0,i.yg)("li",{parentName:"ul"},"El alcance del bloqueo (en este caso, el objeto safeInstance ) se denomina contexto(dominio) de sincronizaci\xf3n ."),(0,i.yg)("li",{parentName:"ul"},'ContextBoundObject puede considerarse como un objeto "remoto", lo que significa que todas las llamadas a m\xe9todos son interceptadas. Para hacer posible esta interceptaci\xf3n, cuando creamos una instancia AutoLock, el CLR en realidad devuelve un proxy: un objeto con los mismos m\xe9todos y propiedades de un objeto  AutoLock , que act\xfaa como intermediario. Es a trav\xe9s de este intermediario que se produce el bloqueo autom\xe1tico. En general, la interceptaci\xf3n agrega alrededor de un microsegundo a cada llamada al m\xe9todo.')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Proxy")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Un proxy es un equipo inform\xe1tico que hace de intermediario entre las conexiones de un cliente y un servidor de destino, filtrando todos los paquetes entre ambos. Siendo t\xfa el cliente, esto quiere decir que el proxy recibe tus peticiones de acceder a una u otra p\xe1gina, y se encarga de transmit\xedrselas al servidor de la web para que esta no sepa que lo est\xe1s haciendo t\xfa.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La sincronizaci\xf3n autom\xe1tica no se puede utilizar para proteger miembros de tipos est\xe1ticos ni clases que no se deriven de ContextBoundObject (por ejemplo, un Windows Form)."),(0,i.yg)("li",{parentName:"ul"},"El bloqueo se aplica internamente de la misma manera. Es de esperar que el siguiente ejemplo produzca el mismo resultado que el anterior:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'[Synchronization]\npublic class AutoLock : ContextBoundObject\n{\n  public void Demo()\n  {\n    Console.Write ("Start...");\n    Thread.Sleep (1000);\n    Console.WriteLine ("end");\n  }\n \n  public void Test()\n  {\n    new Thread (Demo).Start();\n    new Thread (Demo).Start();\n    new Thread (Demo).Start();\n    Console.ReadLine();\n  }\n \n  public static void Main()\n  {\n    new AutoLock().Test();\n  }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"N\xf3tese que hemos colado un Console.ReadLine  al final del Test(). Debido a que solo un hilo puede ejecutar c\xf3digo a la vez en un objeto de esta clase, los tres nuevos hilos permanecer\xe1n bloqueados en el m\xe9todo Demo hasta que Test finalice, lo que requiere que ReadLine se complete. Por lo tanto terminamos con el mismo resultado que antes, pero s\xf3lo despu\xe9s de presionar la tecla Enter. \xa1Este es un martillo de seguridad para subprocesos casi lo suficientemente grande como para impedir cualquier subproceso m\xfaltiple \xfatil dentro de una clase!")))),(0,i.yg)("h4",{id:"extender-contexto-de-sincronizaci\xf3n"},"Extender contexto de sincronizaci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Todavia , no hemos resuelto un problema."),(0,i.yg)("li",{parentName:"ul"},"Necesitar\xedamos un bloqueo alrededor de una declaraci\xf3n como la siguiente, suponiendo que se ejecutara desde otra clase:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"if (safeInstance.Count > 0) safeInstance.RemoveAt (0);\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Un contexto de sincronizaci\xf3n (dominio de sincronizaci\xf3n) puede extenderse m\xe1s all\xe1 del alcance de un solo objeto. De forma predeterminada, si se crea una instancia de un objeto sincronizado desde el c\xf3digo de otro, ambos comparten el mismo contexto (en otras palabras, \xa1un gran candado!). Este comportamiento se puede cambiar especificando un n\xfamero entero como par\xe1metro del atributo."),(0,i.yg)("li",{parentName:"ul"},"El numero corresponde a una constante de la clase SynchronizationAttribute :")),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Constante"),(0,i.yg)("th",{parentName:"tr",align:null},"Significado"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"NOT_SUPPORTED"),(0,i.yg)("td",{parentName:"tr",align:null},"Es el equivalente a no usar el atributo Synchronized.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"SUPPORTED"),(0,i.yg)("td",{parentName:"tr",align:null},"Se une al contexto de sincronizaci\xf3n existente si se crea una instancia desde otro objeto sincronizado; de lo contrario, permanece sin sincronizar.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"REQUIRED (default)"),(0,i.yg)("td",{parentName:"tr",align:null},"Se une al contexto de sincronizaci\xf3n existente si se crea una instancia desde otro objeto sincronizado; de lo contrario, crea un nuevo contexto.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"REQUIRES_NEW"),(0,i.yg)("td",{parentName:"tr",align:null},"Siempre crea un nuevo contexto de sincronizaci\xf3n.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Entonces, si un objeto de clase SynchronizedA crea una instancia de un objeto de clase SynchronizedB, se les dar\xe1n contextos de sincronizaci\xf3n separados si SynchronizedB se declara de la siguiente manera:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"[Synchronization (SynchronizationAttribute.REQUIRES_NEW)]\npublic class SynchronizedB : ContextBoundObject { ...\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuanto mayor sea el alcance de un contexto de sincronizaci\xf3n, m\xe1s f\xe1cil ser\xe1 de gestionar, pero menor ser\xe1 la oportunidad de una concurrencia \xfatil. En el otro extremo de la escala, los contextos de sincronizaci\xf3n separados invitan a estancamientos . Por ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'[Synchronization]\npublic class Deadlock : ContextBoundObject\n{\n  public DeadLock Other;\n  public void Demo() { Thread.Sleep (1000); Other.Hello(); }\n  void Hello()       { Console.WriteLine ("hello");        }\n}\n \npublic class Test\n{\n  static void Main()\n  {\n    Deadlock dead1 = new Deadlock();\n    Deadlock dead2 = new Deadlock();\n    dead1.Other = dead2;\n    dead2.Other = dead1;\n    new Thread (dead1.Demo).Start();\n    dead2.Demo();\n  }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Debido a que cada instancia de Deadlock se crea dentro de Test, una clase no sincronizada, cada instancia obtendr\xe1 su propio contexto de sincronizaci\xf3n y, por lo tanto, su propio bloqueo. Cuando los dos objetos se invocan entre s\xed, se produce un punto muerto (\xa1un segundo, para ser precisos!). ")))),(0,i.yg)("h4",{id:"reentrada"},"Reentrada"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Un m\xe9todo seguro para subprocesos a veces se denomina reentrante, porque se puede pausar a mitad de su ejecuci\xf3n y luego volver a llamarlo en otro subproceso sin efectos negativos. "),(0,i.yg)("li",{parentName:"ul"},"Se dice que un c\xf3digo es reentrante cuando puede ser utilizado concurrentemente por varios threads sin interferencias entre ellos."),(0,i.yg)("li",{parentName:"ul"},"Se llama reentrante si puede ser interrumpido en medio de su ejecuci\xf3n y volver a llamarse de forma segura antes de que las invocaciones anteriores completen su ejecuci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"El  atributo  Synchronization  se tiene que aplicar con el argumento reentrant  en verdadero:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"[Synchronization(true)]\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Entonces el bloqueo del contexto de sincronizaci\xf3n se liberar\xe1 temporalmente cuando la ejecuci\xf3n abandone el contexto."),(0,i.yg)("li",{parentName:"ul"},'En el ejemplo anterior, esto evitar\xeda que se produjera el punto muerto; obviamente deseable. Sin embargo, un efecto secundario es que, durante este \xednterin, cualquier subproceso es libre de llamar a cualquier m\xe9todo en el objeto original ("reingresar" al contexto de sincronizaci\xf3n) y desatar las mismas complicaciones del subproceso m\xfaltiple que uno est\xe1 tratando de evitar en primer lugar. \xc9ste es el problema de la reentrada.'),(0,i.yg)("li",{parentName:"ul"},"Debido a que ","[Synchronization(true)]"," se aplica a nivel de clase, este atributo convierte cada llamada de un m\xe9todo fuera de contexto de la clase en un troyano para reentrada.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/es-es/dotnet/api/system.runtime.remoting.contexts.synchronizationattribute?view=netframework-4.8"},"SynchronizationAttribute Clase")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://bytes.com/topic/c-sharp/answers/830607-synchronization-attributes"},"Synchronization Attributes")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://flylib.com/books/en/3.333.1.22/1/"},"Synchronization Context")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.diranieh.com/NETThreading/MultithreadingBasics.htm"},"Multithreading in .NET")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/vendettamit/synchronizing-threads-in-a-multithreaded-application-in-net-C-Sharp/"},'The Problem "Concurrency"')),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.albahari.com/threading/part2.aspx"},"Synchronization Essentials"))))),(0,i.yg)("h2",{id:"clase-interlocked"},"Clase InterLocked"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La clase Interlocked proporciona un conjunto de m\xe9todos que le permiten realizar operaciones at\xf3micas en variables compartidas."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si varios subprocesos modifican una variable compartida al mismo tiempo, el valor final de la variable puede ser impredecible o incorrecto."),(0,i.yg)("li",{parentName:"ul"},"La raz\xf3n es que incrementar una variable no es una operaci\xf3n at\xf3mica porque el programa necesita realizar tres pasos:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Primero, lea el valor actual de la variable compartida."),(0,i.yg)("li",{parentName:"ul"},"En segundo lugar, aumente el valor."),(0,i.yg)("li",{parentName:"ul"},"En tercer lugar, escriba el nuevo valor en la variable compartida."))),(0,i.yg)("li",{parentName:"ul"},"Si el subproceso uno est\xe1 aumentando el valor, pero a\xfan no escribe el nuevo valor en la variable compartida (en el paso 2), el subproceso dos puede leer el valor original y aumentarlo. Como resultado, es posible que se pierda la actualizaci\xf3n del hilo uno."),(0,i.yg)("li",{parentName:"ul"},"Para resolver este problema de sincronizaci\xf3n, puede utilizar el m\xe9todo  Increment() de la  clase Interlocked para aumentar la variable compartida de forma at\xf3mica."),(0,i.yg)("li",{parentName:"ul"},"A diferencia de los incrementos regulares, el m\xe9todo  Interlocked.Increament() incrementa la variable compartida de forma at\xf3mica, asegurando que la operaci\xf3n se complete antes de que otro subproceso pueda acceder a la variable."),(0,i.yg)("li",{parentName:"ul"},"El siguiente programa demuestra c\xf3mo utilizar la clase  InterLocked para realizar incrementos at\xf3micos de una variable counter compartida en dos subprocesos:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'int counter = 0;\n\nvoid Increase()\n{\n    for (int i = 0; i < 1000000; i++)\n    {\n        Interlocked.Increment(ref counter);\n\n    }\n    Console.WriteLine("The counter is " + counter);\n}\n\nTask.Run(() => Increase());\nTask.Run(() => Increase());\n\nConsole.ReadLine();\n\n')),(0,i.yg)("h4",{id:"c\xf3mo-funciona-2"},"C\xf3mo funciona"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Primero, declare una variable counter e inicialice su valor a cero:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"int counter = 0;\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En segundo lugar, defini una funci\xf3n  Increase() que incrementa  counter  con el m\xe9todo Increment()  de la clase Interlocked en un bucle y muestre el valor  counter en la consola:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},'void Increase()\n{\n    for (int i = 0; i < 1000000; i++)\n    {\n        Interlocked.Increment(ref counter);\n\n    }\n    Console.WriteLine("The counter is " + counter);\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En tercer lugar, cree dos tareas que ejecuten el m\xe9todo  Increase() en subprocesos separados. Ambas tareas (o subprocesos) incrementar\xe1n la variable counter simult\xe1neamente:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Task.Run(() => Increase());\nTask.Run(() => Increase());\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Finalmente, use Console.ReadLine() para pausar el programa y dejar suficiente tiempo para que se completen las dos tareas antes de presionar la tecla Intro (o la tecla Intro):")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Console.ReadLine();\n")),(0,i.yg)("h4",{id:"ejemplo-para-entender-interlocked-en-c"},"Ejemplo para entender Interlocked en C#:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C#, las Condiciones de Carrera ocurren cuando tenemos una variable compartida por varios subprocesos y estos subprocesos quieren modificar la variable simult\xe1neamente. "),(0,i.yg)("li",{parentName:"ul"},"Una variable es problem\xe1tica si accedemos a ella en un entorno multiproceso. Incluso aumentar una variable en 1 es problem\xe1tico. Esto se debe a que la operaci\xf3n no es at\xf3mica. Un simple incremento de variable no es una operaci\xf3n at\xf3mica."),(0,i.yg)("li",{parentName:"ul"},"De hecho, se divide en tres partes: Lectura, Aumento y Escritura. Dado que tenemos tres operaciones, dos hilos pueden ejecutarlas de tal manera que incluso si aumentamos el valor de una variable dos veces, solo tiene efecto un aumento."),(0,i.yg)("li",{parentName:"ul"},"\xbfQu\xe9 sucede si dos subprocesos intentan incrementar una variable secuencialmente? Entendamos esto con un ejemplo. Por favor, eche un vistazo a la siguiente tabla. Aqu\xed, tenemos el Hilo 1 en la columna uno y el Hilo 2 en la columna 2. Y al final, una columna de valor representa el valor de la variable compartida. En este caso, el resultado podr\xeda ser que el valor final de la variable sea 1 o 2. Veamos una posibilidad:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-1.png?ezimgfmt=ng%3Awebp%2Fngcb1%2Frs%3Adevice%2Frscb1-1",alt:"Posibilidad 1"})),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-2.png?ezimgfmt=ng%3Awebp%2Fngcb1%2Frs%3Adevice%2Frscb1-1",alt:"Posibilidad 1 explicaci\xf3n"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El subproceso 1 incrementa el valor, as\xed como el subproceso 2, tambi\xe9n incrementa el valor y ambos lo incrementan a 1 en la memoria. Para una mejor comprensi\xf3n, eche un vistazo a la imagen a continuaci\xf3n:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-3.png?ezimgfmt=ng%3Awebp%2Fngcb1%2Frs%3Adevice%2Frscb1-1",alt:"Imagen"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Una vez que ambos subprocesos incrementan el valor a 1 en la memoria. Luego, el subproceso 1 vuelve a escribir en la variable 1 y el subproceso 2 tambi\xe9n vuelve a escribir en la variable 1, una vez m\xe1s. Para una mejor comprensi\xf3n, eche un vistazo a la imagen a continuaci\xf3n:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-4.png?ezimgfmt=ng%3Awebp%2Fngcb1%2Frs%3Adevice%2Frscb1-1",alt:"imagen 2"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Esto significa que, como puedes ver, dependiendo del orden de ejecuci\xf3n de los m\xe9todos, vamos a determinar el valor de la variable. Aunque aumentamos el valor dos veces usando dos subprocesos diferentes porque est\xe1bamos en un entorno multiproceso, ten\xedamos una condici\xf3n de carrera, lo que significa que ahora no tenemos una operaci\xf3n determinista porque a veces podr\xeda ser uno y otras veces podr\xeda ser dos."),(0,i.yg)("li",{parentName:"ul"},"Para solucionar la condici\xf3n de carrera, usamos Interlocked o lock.")),(0,i.yg)("h4",{id:"clase-interlocked-1"},"Clase interlocked"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Es una clase est\xe1tica y, por lo tanto, proporciona muchos m\xe9todos est\xe1ticos."),(0,i.yg)("li",{parentName:"ul"},"La clase Interlocked pertenece al espacio de nombres System.Threading."),(0,i.yg)("li",{parentName:"ul"},'Entonces, en lugar de usar operadores de suma, resta y asignaci\xf3n, podemos usar los m\xe9todos Agregar(Add), Incrementar(Increment), Decrementar(Decrement), Intercambiar(Exchange) y "Comparar y intercambiar(CompareExhange)" de la clase.')),(0,i.yg)("h4",{id:"ejemplo-con-el-m\xe9todo-add"},"Ejemplo con el m\xe9todo add()"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace InterlockedDemo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long SumValueWithoutInterlocked = 0;\n            long SumValueWithInterlocked = 0;\n            Parallel.For(0, 100000, number =>\n            {\n                SumValueWithoutInterlocked = SumValueWithoutInterlocked + number;\n                Interlocked.Add(ref SumValueWithInterlocked, number);\n            });\n            \n            Console.WriteLine($"Sum Value Without Interlocked: {SumValueWithoutInterlocked}");\n            Console.WriteLine($"Sum Value With Interlocked: {SumValueWithInterlocked}");\n            \n            Console.ReadKey();\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"El valor de suma con  interlocked siempre le da el mismo resultado, mientras que el valor de suma sin Interlocked le da un resultado diferente. Eso significa que el m\xe9todo Interlocked.Add proporciona seguridad para subprocesos a la variable compartida."),(0,i.yg)("li",{parentName:"ul"},"el bucle Parallel For utiliza subprocesos m\xfaltiples.")))),(0,i.yg)("h4",{id:"m\xe9todo-exchange-y-compareexchange"},"M\xe9todo Exchange y CompareExchange"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo Exchange de Interlocked Class en C# consiste en intercambiar at\xf3micamente los valores de las variables especificadas. El segundo valor podr\xeda ser un valor o una variable. Para una mejor comprensi\xf3n, eche un vistazo a la imagen a continuaci\xf3n:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-9.png?ezimgfmt=ng:webp/ngcb1",alt:"Imagen 3"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo CompareExchange de Interlocked Class en C# se utiliza para combinar dos operaciones. Compara dos valores y almacena el tercer valor en una de las variables. Si ambos valores comparados son iguales, reemplaza el valor de la variable del primer par\xe1metro con el valor del segundo par\xe1metro (tercer valor)."),(0,i.yg)("li",{parentName:"ul"},"Para una mejor comprensi\xf3n, eche un vistazo a la imagen a continuaci\xf3n. Aqu\xed, creamos una variable entera y luego le asignamos el valor 20. Luego llamamos al m\xe9todo Interlocked.CompareExchange para comparar la variable x con 20 y, dado que ambas son iguales, reemplazar\xe1 x con DateTime.Now.Day, el d\xeda actual del mes:")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-10.png?ezimgfmt=ng:webp/ngcb1",alt:"Imagen 4"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"using System;\nusing System.Threading;\nnamespace InterlockedDemo\n{\n    class Program\n    {\n        static long x;\n        static void Main(string[] args)\n        {\n            Thread thread1 = new Thread(new ThreadStart(SomeMethod));\n            thread1.Start();\n            thread1.Join();\n\n       \n            Console.WriteLine(Interlocked.Read(ref Program.x));\n\n            Console.ReadKey();\n        }\n\n        static void SomeMethod()\n        {\n           \n            Interlocked.Exchange(ref Program.x, 20);\n\n        \n            long result = Interlocked.CompareExchange(ref Program.x, 50, 20);\n\n       \n            Console.WriteLine(result);\n        }\n    }\n}\n\n")),(0,i.yg)("h4",{id:"interlocked-vs-lock"},"Interlocked vs lock"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ambos permiten la sincronizaci\xf3n de subprocesos y evitan condiciones de carrera cuando varios subprocesos intentan acceder a la misma variable compartida al mismo tiempo. Pero tienen algunas diferencias:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Interlocked solo proporciona operaciones at\xf3micas como Increment, Decrement,Exchange , etc. Estos m\xe9todos son \xfatiles cuando necesita realizar operaciones en una variable compartida."),(0,i.yg)("li",{parentName:"ul"},"La declaraci\xf3n lock proporciona exclusi\xf3n mutua que permite que solo un subproceso pueda ejecutar un bloque cr\xedtico de c\xf3digo a la vez."))),(0,i.yg)("li",{parentName:"ul"},"Puede ejecutar lock en un bloque de c\xf3digo de forma at\xf3mica, mientras que Interlocked puede realizar operaciones limitadas en una variable compartida de forma at\xf3mica. En otras palabras, Interlocked es m\xe1s liviano que el lock."),(0,i.yg)("li",{parentName:"ul"},"Por lo tanto, si se logra la misma tarea usando ambos lock y  interlocked, se recomienda usar Interlocked en C#. Sin embargo, en algunas situaciones, Interlocked no funcionar\xe1 y, en esas situaciones, necesitamos usar lock."),(0,i.yg)("li",{parentName:"ul"},"Entendamos esto con un ejemplo. Por favor, eche un vistazo al siguiente c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace InterlockedDemo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long IncrementValue= 0;\n            long SumValue = 0;\n            Parallel.For(0, 100000, number =>\n            {\n                Interlocked.Increment(ref IncrementValue);\n                Interlocked.Add(ref SumValue, IncrementValue);\n            });\n            \n            Console.WriteLine($"Increment Value With Interlocked: {IncrementValue}");\n            Console.WriteLine($"Sum Value With Interlocked: {SumValue}");\n\n            Console.ReadKey();\n        }\n    }\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Como puede ver en el resultado anterior, obtenemos diferentes valores de suma incluso despu\xe9s de usar Interlocked. \xbf Por qu\xe9 ? Esto se debe a que existe una condici\xf3n de carrera. Entonces podr\xedas estar pensando que estamos usando el m\xe9todo Interlocked.Add y que no deber\xeda haber ninguna condici\xf3n de carrera. \xbfBien? Pero existe una condici\xf3n de carrera debido a lo siguiente.")),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://dotnettutorials.net/wp-content/uploads/2022/06/word-image-27490-13.png?ezimgfmt=ng:webp/ngcb1",alt:"Imagen que explica"})),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los m\xe9todos Increment y Add individualmente son seguros para subprocesos, pero la uni\xf3n de estos dos m\xe9todos no es segura para subprocesos."),(0,i.yg)("li",{parentName:"ul"},"Para una mejor comprensi\xf3n, piense en el c\xf3digo de la siguiente manera. Un hilo comienza a ejecutar el m\xe9todo Increment. Mientras el subproceso viaja al m\xe9todo Add, otro subproceso podr\xeda tener la oportunidad de ejecutar el m\xe9todo Increment, que cambiar\xe1 el IncrementValue nuevamente. Y por lo tanto, el valor de la variable IncrementValue ya se increment\xf3 antes de que el primer hilo tuviera tiempo de hacer esa suma. Entonces, esta es la raz\xf3n por la cual existe una condici\xf3n de carrera."),(0,i.yg)("li",{parentName:"ul"},"Entonces, existe una condici\xf3n de carrera entre estas dos operaciones, es decir, Incrementar y Agregar. Individualmente, ambos son seguros para subprocesos, juntos, no son seguros para subprocesos porque mientras el subproceso uno viaja del m\xe9todo Increment al m\xe9todo Add, m\xfaltiples, m\xfaltiples, m\xfaltiples subprocesos podr\xedan ejecutar el m\xe9todo Increment. Y es por eso que existe una condici\xf3n de carrera.")),(0,i.yg)("h4",{id:"c\xf3mo-resolver-la-condici\xf3n-de-carrera-anterior"},"\xbfC\xf3mo resolver la condici\xf3n de carrera anterior?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Como tenemos varias operaciones y queremos que sean ejecutadas solo por un hilo a la vez, podemos usar lock. Para utilizar lock, necesitamos crear una instancia de un objeto. Se recomienda tener un objeto dedicado para lock. La idea es que hagamos cerraduras(lock) a base de objetos. "),(0,i.yg)("li",{parentName:"ul"},"Entonces, si hay, digamos, dos subprocesos intentando acceder al bloque de bloqueo, solo un subproceso podr\xe1 ingresar mientras el otro espera. Y cuando el subproceso uno sale del bloque de bloqueo, el subproceso dos podr\xe1 ingresar al bloque de bloqueo y ejecutar las dos l\xedneas de c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading.Tasks;\n\nnamespace InterlockedDemo\n{\n    class Program\n    {\n        static object lockObject = new object();\n\n        static void Main(string[] args)\n        {\n            long IncrementValue= 0;\n            long SumValue = 0;\n            \n            Parallel.For(0, 10000, number =>\n            {\n                //Before lock Parallel \n\n                lock(lockObject)\n                {\n                    IncrementValue++;\n                    SumValue += IncrementValue;\n                }\n\n                //After lock Parallel \n            });\n            \n            Console.WriteLine($"Increment Value With lock: {IncrementValue}");\n            Console.WriteLine($"Sum Value With lock: {SumValue}");\n\n            Console.ReadKey();\n        }\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"info")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.csharptutorial.net/csharp-concurrency/c-interlocked/"},"C# Interlocked")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-7.0"},"Interlocked Class")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/"},"Interlocked Class in c# Threading")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://duongnt.com/interlocked-synchronization/"},"Synchronization with Interlocked in C#")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://dotnettutorials.net/lesson/interlocked-vs-lock-in-csharp/"},"Interlocked vs Lock in C#"))))),(0,i.yg)("h2",{id:"region"},"Region"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Visual Studio .NET nos brinda algunas herramientas muy \xfatiles para mejorar la legibilidad de nuestro c\xf3digo. Una que me gusta especialmente es la directiva #region que nos permite contraer el c\xf3digo de forma personalizada."),(0,i.yg)("li",{parentName:"ul"},"Las regiones se crean en este formato:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"#region NombreRegi\xf3n\n\nTu c\xf3digo aqu\xed\n\n#endregion\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Todo lo que est\xe9 dentro de las directivas ser\xe1 colapsable."),(0,i.yg)("li",{parentName:"ul"},"Todos los \u201ctextos en gris\u201d son los nombres de la regi\xf3n. "),(0,i.yg)("li",{parentName:"ul"},"A trav\xe9s del nombre pod\xe9s desplegar el c\xf3digo que contiene la regi\xf3n.")))),(0,i.yg)("h2",{id:"usos-del-signo-"},'Usos del signo "?"'),(0,i.yg)("h4",{id:"tipos-de-valor-nullable"},"Tipos de Valor Nullable"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C#, los tipos de valor (como int, double, bool) no pueden ser null de manera predeterminada. Sin embargo, al usar el signo ?, puedes declarar que un tipo de valor puede aceptar el valor null."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"int? optionalNumber = null; // El valor puede ser null o un n\xfamero\noptionalNumber = 5;         // Ahora tiene un valor de 5\n\n")),(0,i.yg)("h4",{id:"tipos-de-referencia-nullable"},"Tipos de Referencia Nullable"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A partir de C# 8.0, con la introducci\xf3n de los nullable reference types, puedes usar el signo ? para indicar que una referencia (por ejemplo, una variable de tipo string) puede ser null. Este comportamiento es opcional y puedes activarlo o desactivarlo en tu proyecto."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'string? optionalString = null; // Puede ser null\noptionalString = "Hello";      // Ahora tiene un valor\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Cuando usas string?, est\xe1s diciendo que la variable puede contener un string o null. Si no usas el ?, el compilador asumir\xe1 que no deber\xeda ser null y mostrar\xe1 advertencias si no lo cumples.")))),(0,i.yg)("h4",{id:"operador-condicional-null-"},"Operador Condicional Null (?.)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El operador ?. se utiliza para acceder a miembros o propiedades de un objeto de manera segura, evitando una excepci\xf3n NullReferenceException si el objeto es null. Si el objeto es null, la expresi\xf3n se eval\xfaa como null."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Person? person = null;\nstring? name = person?.Name; // Si person es null, name ser\xe1 null\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este caso, ?. se usa para verificar si person es null antes de intentar acceder a su propiedad Name.")))),(0,i.yg)("h4",{id:"operador-null-coalescing-"},"Operador Null-Coalescing (??)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El operador ?? se utiliza para proporcionar un valor predeterminado si una expresi\xf3n es null. Esto es \xfatil cuando quieres garantizar que una variable no sea null."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'string? name = null;\nstring displayName = name ?? "Valor por defecto"; // Si name es null, se usa el valor por defecto\n\n')),(0,i.yg)("h4",{id:"en-par\xe1metros-opcionales"},"En Par\xe1metros Opcionales"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Aunque el signo ? no se usa directamente para especificar que un par\xe1metro es opcional, puedes declarar un par\xe1metro con un valor predeterminado, lo que hace que sea opcional al invocar el m\xe9todo."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'void PrintMessage(string message = "Mensaje por defecto")\n{\n    Console.WriteLine(message);\n}\n\nPrintMessage(); // Muestra: Mensaje por defecto\nPrintMessage("Hello"); // Muestra: Hello\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Aqu\xed, el par\xe1metro message es opcional porque tiene un valor predeterminado asignado.")))),(0,i.yg)("h2",{id:"como-compila-en-c"},"Como compila en C#"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La compilaci\xf3n en C# es un proceso que convierte el c\xf3digo fuente en un programa ejecutable. A continuaci\xf3n, describir\xe9 cada paso del proceso, desde la escritura del c\xf3digo hasta la ejecuci\xf3n, incluyendo aspectos como using, m\xe9todos de extensi\xf3n y otros elementos. Este proceso se realiza en varias etapas:")),(0,i.yg)("h4",{id:"1--escribir-el-c\xf3digo-fuente"},"1- Escribir el c\xf3digo fuente"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Al escribir un programa en C#, se suelen tener en cuenta varias estructuras y elementos:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"using: Se utiliza para incluir espacios de nombres (namespaces) que contienen clases y m\xe9todos que se pueden utilizar en el c\xf3digo. Esto permite acceder a clases y m\xe9todos sin tener que usar el nombre completo del espacio de nombres."),(0,i.yg)("li",{parentName:"ul"},"Clases: Se definen con la palabra clave class y son la base de la programaci\xf3n orientada a objetos en C#. Contienen m\xe9todos, propiedades y otros miembros."),(0,i.yg)("li",{parentName:"ul"},"M\xe9todos de Extensi\xf3n: Son m\xe9todos est\xe1ticos que permiten agregar funcionalidad a tipos existentes sin modificar el tipo original. Se definen en una clase est\xe1tica y el primer par\xe1metro del m\xe9todo se precede con this."),(0,i.yg)("li",{parentName:"ul"},"Elementos Globales: A partir de C# 10, se pueden definir archivos de c\xf3digo globales que no requieren una clase envolvente y que pueden contener using, m\xe9todos, propiedades, etc.")))),(0,i.yg)("h4",{id:"2--proceso-de-compilaci\xf3n"},"2- Proceso de compilaci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Antes de que el c\xf3digo se convierta en algo que la computadora puede ejecutar, el compilador  se asegura de que todo est\xe9 en orden:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Lee los archivos: El compilador revisa todos los archivos de c\xf3digo en el proyecto. "),(0,i.yg)("li",{parentName:"ul"},"Verificaci\xf3n de Importaciones: El compilador verifica qu\xe9 bibliotecas/m\xf3dulos (como System) est\xe1s utilizando con using. Esto significa que mira si tienes todo lo que necesitas para que tu c\xf3digo funcione. El compilador tambi\xe9n verifica que las bibliotecas/m\xf3dulos correspondientes a los espacios de nombres especificados est\xe9n disponibles en el proyecto. Si alguna falta, se generar\xe1 un error de compilaci\xf3n."))),(0,i.yg)("li",{parentName:"ul"},"Por \xfaltimo, convierte tu c\xf3digo a un formato intermedio llamado IL (Intermediate Language). Este formato es como un idioma que la computadora entiende, pero que a\xfan no est\xe1 listo para ejecutarse.")),(0,i.yg)("h5",{id:"qu\xe9-pasa-con-los-using"},"\xbfQu\xe9 pasa con los using?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando el compilador procesa cada archivo de tu proyecto, busca todas las declaraciones de using que tiene. Esto incluye tanto las declaraciones normales (using EspacioDeNombres;) como las declaraciones global using."),(0,i.yg)("li",{parentName:"ul"},"Cuando el compilador encuentra una declaraci\xf3n de global using, la trata de manera especial. Sabe que esa declaraci\xf3n significa que el espacio de nombres que est\xe1s importando estar\xe1 disponible en todos los archivos del proyecto."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si declaras ",(0,i.yg)("inlineCode",{parentName:"li"},"global using System;"),", el compilador sabe que System es un espacio de nombres que se puede usar en cualquier archivo de tu proyecto."),(0,i.yg)("li",{parentName:"ul"},'A partir de que el compilador ve global using, no necesita que cada archivo individual incluya using System; en la parte superior. Esto se debe a que ya est\xe1 "al tanto" de que ese espacio de nombres est\xe1 disponible para cualquier clase o m\xe9todo dentro del proyecto.'),(0,i.yg)("li",{parentName:"ul"},"As\xed que cuando compilas ClaseA.cs o ClaseB.cs, el compilador no necesita verificar si hay un using System; en esos archivos. Sabe que System est\xe1 disponible por la declaraci\xf3n global using."),(0,i.yg)("li",{parentName:"ul"},"No se genera ning\xfan c\xf3digo IL adicional para las declaraciones global using ."),(0,i.yg)("li",{parentName:"ul"},"Cuando usas los tipos de esos espacios de nombres en tu c\xf3digo, el compilador usa los tipos que est\xe1n disponible en el contexto del proyecto. Esto significa que, aunque no hay una declaraci\xf3n \u201cusing \u2026\u201d visible en el archivo, el compilador trata esos tipos como si fueran importados.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Contexto del proyecto")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},'El "contexto del proyecto" en programaci\xf3n se refiere al conjunto de configuraciones, recursos y dependencias que est\xe1n disponibles de manera global dentro de un proyecto de software. En el caso de C#, esto incluye elementos como:',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Espacios de nombres (namespaces): Determina qu\xe9 clases, interfaces, estructuras, etc., est\xe1n disponibles para usar en los archivos de c\xf3digo sin necesidad de volver a importarlos. Por ejemplo, cuando usas una declaraci\xf3n global using, est\xe1s a\xf1adiendo un espacio de nombres al contexto del proyecto."),(0,i.yg)("li",{parentName:"ul"},"Configuraciones del compilador: Estas incluyen opciones como la versi\xf3n de C# que se est\xe1 usando, la configuraci\xf3n de advertencias, opciones de optimizaci\xf3n, entre otras."),(0,i.yg)("li",{parentName:"ul"},"Dependencias del proyecto: Esto abarca las bibliotecas externas o paquetes NuGet que el proyecto utiliza. Estas dependencias tambi\xe9n forman parte del contexto, ya que el compilador y el entorno de ejecuci\xf3n necesitan saber qu\xe9 bibliotecas est\xe1n disponibles."),(0,i.yg)("li",{parentName:"ul"},"Archivos comunes: Cualquier archivo o recurso compartido (como im\xe1genes, archivos de configuraci\xf3n, etc.) que est\xe9 disponible para todas las partes del proyecto tambi\xe9n forma parte del contexto."),(0,i.yg)("li",{parentName:"ul"},"Configuraci\xf3n de salida: Este es el entorno o la configuraci\xf3n que indica c\xf3mo se debe generar el proyecto, por ejemplo, si es un proyecto de consola, una aplicaci\xf3n web, etc.")))))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Es importante aclarar que un using normal tampoco genera c\xf3digo IL adicional.  Solo le indica al compilador donde se encuentra el m\xf3dulo/biblioteca que va a usar para que la pueda analizar.")))),(0,i.yg)("h5",{id:"qu\xe9-pasa-con-los-m\xe9todos-de-extensi\xf3n"},"\xbfQu\xe9 pasa con los m\xe9todos de extensi\xf3n?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Antes de que ocurra la ejecuci\xf3n, el c\xf3digo C# se compila a c\xf3digo Intermedio de Lenguaje (IL). Este c\xf3digo IL es el que realmente se ejecuta en la m\xe1quina virtual de .NET (Common Language Runtime, CLR)."),(0,i.yg)("li",{parentName:"ul"},"Cuando utilizas un m\xe9todo de extensi\xf3n en tu c\xf3digo, el compilador busca en las clases est\xe1ticas que est\xe1n disponibles en el contexto del proyecto y en  los espacios de nombres importados."),(0,i.yg)("li",{parentName:"ul"},"Si encuentra un m\xe9todo de extensi\xf3n que coincide con el tipo y los par\xe1metros, lo considera un m\xe9todo de instancia."),(0,i.yg)("li",{parentName:"ul"},"Cuando compilas tu c\xf3digo, el compilador convierte las llamadas al m\xe9todo de extensi\xf3n en llamadas a m\xe9todos est\xe1ticos."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si llamas a nombre.Saludar(), el compilador genera IL que se traduce en una llamada a Extensiones.Saludar(nombre)."),(0,i.yg)("li",{parentName:"ul"},"Donde Extensiones es una clase como:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public static class Extensiones\n{\n    public static string Saludar(this string nombre)\n    {\n        return $"Hola, {nombre}!";\n    }\n}\n\n')),(0,i.yg)("h4",{id:"3--ejecuci\xf3n-del-progama"},"3- Ejecuci\xf3n del progama"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando decides ejecutar tu programa, la computadora utiliza el CLR (Common Language Runtime) para convertir ese IL en c\xf3digo nativo, que es lo que realmente se ejecuta en tu m\xe1quina.")),(0,i.yg)("h5",{id:"1-compilaci\xf3n-a-c\xf3digo-il"},"1. Compilaci\xf3n a C\xf3digo IL"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Antes de que ocurra la ejecuci\xf3n, el c\xf3digo C# se compila a c\xf3digo Intermedio de Lenguaje (IL). Este c\xf3digo IL es el que realmente se ejecuta en la m\xe1quina virtual de .NET (Common Language Runtime, CLR).")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\xbfQu\xe9 es el C\xf3digo IL?")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"C\xf3digo IL (Intermediate Language): Es el c\xf3digo intermedio generado por el compilador cuando compilas tu c\xf3digo C#. Este c\xf3digo no es espec\xedfico de la m\xe1quina y debe ser ejecutado por el CLR, que lo convierte en c\xf3digo m\xe1quina. El c\xf3digo IL contiene referencias a tipos, m\xe9todos y otros elementos necesarios para la ejecuci\xf3n de la aplicaci\xf3n.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\xbfC\xf3mo Usa el CLR la Informaci\xf3n de Tipo?")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Informaci\xf3n de Tipo:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Cuando escribes tu c\xf3digo en C#, el compilador lo convierte en c\xf3digo IL. Durante este proceso, el compilador tambi\xe9n recoge informaci\xf3n sobre los tipos que has utilizado (como clases, estructuras, enumeraciones, etc.) y sus m\xe9todos."),(0,i.yg)("li",{parentName:"ul"},"Esta informaci\xf3n se almacena en los metadatos del c\xf3digo IL. Los metadatos son datos que describen otros datos, lo que permite que el CLR comprenda la estructura del c\xf3digo, qu\xe9 tipos hay disponibles y c\xf3mo interact\xfaan entre s\xed."),(0,i.yg)("li",{parentName:"ul"},"Ejemplo: Sup\xf3n que tienes una clase Empleado y un m\xe9todo CalcularSalario() en esa clase. Cuando compilas tu c\xf3digo, el compilador genera c\xf3digo IL que incluye la definici\xf3n de Empleado y la firma de CalcularSalario().")))))),(0,i.yg)("h5",{id:"2-carga-de-ensambles"},"2. Carga de Ensambles"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Durante la ejecuci\xf3n, el CLR se encarga de cargar los ensambles (los archivos DLL o EXE generados durante la compilaci\xf3n) necesarios para tu aplicaci\xf3n.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\xbfQu\xe9 es un Ensamble?")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Ensamble: Un ensamble es el bloque fundamental de la programaci\xf3n en .NET. Se refiere a un archivo que contiene el c\xf3digo compilado de tu aplicaci\xf3n, que puede ser un archivo .DLL (Dynamic Link Library) o un archivo .EXE (ejecutable)."),(0,i.yg)("li",{parentName:"ul"},"Los ensamblados contienen el c\xf3digo IL (Intermediate Language), metadatos sobre los tipos y m\xe9todos que contiene, y otros recursos como im\xe1genes o cadenas de texto que pueden ser utilizados por la aplicaci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"Cuando inicias una aplicaci\xf3n .NET, el CLR se encarga de cargar los ensamblados necesarios. Esto significa que busca los archivos .DLL o .EXE que tu aplicaci\xf3n necesita para ejecutarse."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si tu aplicaci\xf3n utiliza un ensamble llamado MiBiblioteca.dll, el CLR localizar\xe1 este archivo en el sistema de archivos."),(0,i.yg)("li",{parentName:"ul"},"Resoluci\xf3n de Dependencias:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Si tu aplicaci\xf3n depende de otros ensamblados (por ejemplo, si MiBiblioteca.dll depende de OtraBiblioteca.dll), el CLR tambi\xe9n se encargar\xe1 de cargar esos ensamblados dependientes."),(0,i.yg)("li",{parentName:"ul"},"Esto asegura que todos los tipos y m\xe9todos requeridos est\xe9n disponibles durante la ejecuci\xf3n."))),(0,i.yg)("li",{parentName:"ul"},"Una vez que el CLR ha encontrado los ensamblados, los carga en memoria. Esto implica convertir el c\xf3digo IL en c\xf3digo m\xe1quina que puede ser ejecutado por el procesador."),(0,i.yg)("li",{parentName:"ul"},"Solo se cargan en memoria los ensamblados que son realmente necesarios en ese momento, lo que optimiza el uso de recursos.")))),(0,i.yg)("h5",{id:"c\xf3mo-ayuda-global-using-al-clr"},"\xbfC\xf3mo Ayuda global using al CLR?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Conocimiento de Tipos Disponibles:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Cuando declaras un global using, el compilador (y por ende el CLR) toma nota de los espacios de nombres y los tipos que estar\xe1n disponibles en todo el proyecto. Esto significa que no necesitas declarar cada using en cada archivo, ya que el CLR ya sabe que esos tipos son accesibles."))),(0,i.yg)("li",{parentName:"ul"},"Resoluci\xf3n Eficiente de Referencias:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Gracias a que el CLR tiene esta informaci\xf3n sobre los tipos disponibles, puede resolver referencias a esos tipos de manera m\xe1s eficiente durante la ejecuci\xf3n. No tiene que volver a buscar los espacios de nombres cada vez que se encuentra una referencia en un archivo "),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si en varios archivos de tu proyecto necesitas usar la clase Empleado del espacio de nombres MiAplicacion.Modelos, puedes agregarlo como global using MiAplicacion.Modelos;. Ahora, cada archivo en el proyecto puede referirse a Empleado sin necesidad de declarar expl\xedcitamente el using.")))),(0,i.yg)("h5",{id:"3-revisar-el-c\xf3digo"},"3. Revisar el c\xf3digo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Antes de que el CLR ejecute cualquier c\xf3digo IL, debe asegurarse de que todos los tipos y m\xe9todos que se van a utilizar est\xe1n disponibles y son accesibles."),(0,i.yg)("li",{parentName:"ul"},"Esto implica que el CLR revisa el c\xf3digo IL para encontrar las clases, estructuras y m\xe9todos que va a usar la aplicaci\xf3n. Necesita confirmar que estos elementos est\xe1n definidos y que el c\xf3digo puede acceder a ellos.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Busqueda de tipo")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Cuando el c\xf3digo IL hace referencia a un tipo, el CLR busca en los ensambles cargados para encontrar la definici\xf3n de ese tipo.")),(0,i.yg)("h5",{parentName:"div",id:"c\xf3mo-funciona-la-b\xfasqueda-de-tipos"},"\xbfC\xf3mo Funciona la B\xfasqueda de Tipos?"),(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Referencia a un Tipo en IL:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Cuando tu c\xf3digo IL hace referencia a un tipo (por ejemplo, una clase o estructura que has definido), el CLR necesita encontrar la definici\xf3n de ese tipo para poder usarlo. Esto ocurre, por ejemplo, cuando intentas crear una instancia de una clase o llamar a un m\xe9todo en ella."))),(0,i.yg)("li",{parentName:"ul"},"B\xfasqueda en Ensambles Cargados:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"El CLR busca en los ensamblados que ya han sido cargados en memoria. Esto significa que revisa todos los archivos .DLL o .EXE que ha cargado previamente y que est\xe1n disponibles para tu aplicaci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"Por ejemplo, si tu c\xf3digo IL hace referencia a un tipo llamado Empleado, el CLR buscar\xe1 en los ensamblados que ha cargado para encontrar d\xf3nde est\xe1 definida la clase Empleado."))),(0,i.yg)("li",{parentName:"ul"},"Proceso de Resoluci\xf3n:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Si encuentra la definici\xf3n del tipo en uno de los ensamblados, el CLR utilizar\xe1 esa definici\xf3n para ejecutar el c\xf3digo IL. Esto incluye la creaci\xf3n de instancias del tipo, la invocaci\xf3n de m\xe9todos, y el acceso a sus propiedades."),(0,i.yg)("li",{parentName:"ul"},"Si no puede encontrar la definici\xf3n, se lanzar\xe1 una excepci\xf3n (por ejemplo, TypeLoadException), indicando que el tipo no est\xe1 disponible.")))))),(0,i.yg)("h5",{id:"4-verificaci\xf3n-de-errores"},"4. Verificaci\xf3n de Errores"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Durante esta fase de \u201crevisar el c\xf3digo\u201d, el CLR tambi\xe9n busca posibles errores, como referencias a tipos que no existen o m\xe9todos que no se pueden encontrar."),(0,i.yg)("li",{parentName:"ul"},"Si encuentra alg\xfan problema, como un tipo no definido (por ejemplo, si el c\xf3digo hace referencia a una clase que no se ha cargado), lanzar\xe1 una excepci\xf3n y detendr\xe1 la ejecuci\xf3n del programa."),(0,i.yg)("li",{parentName:"ul"},"Esto garantiza que el programa est\xe9 en un estado correcto y que todos los elementos necesarios est\xe9n disponibles antes de comenzar la ejecuci\xf3n.")),(0,i.yg)("h5",{id:"5-inicio-de-la-ejecuci\xf3n"},"5. Inicio de la Ejecuci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Una vez que el CLR ha hecho todas las validaciones y verificaciones necesarias, comienza a ejecutar el c\xf3digo IL."),(0,i.yg)("li",{parentName:"ul"},"Este proceso implica la traducci\xf3n del c\xf3digo IL a c\xf3digo m\xe1quina espec\xedfico de la arquitectura de la computadora en la que se est\xe1 ejecutando."),(0,i.yg)("li",{parentName:"ul"},"La ejecuci\xf3n del c\xf3digo IL se realiza mediante un proceso llamado Just-In-Time Compilation (JIT), donde el CLR compila las instrucciones IL en tiempo de ejecuci\xf3n a medida que se necesitan.")),(0,i.yg)("h5",{id:"6manejo-de-excepciones-y-recursos"},"6.Manejo de Excepciones y Recursos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Si se producen excepciones durante la ejecuci\xf3n (como referencias a tipos que no est\xe1n definidos), el CLR las maneja y puede lanzar errores que indiquen problemas en tiempo de ejecuci\xf3n."),(0,i.yg)("li",{parentName:"ul"},"La gesti\xf3n de recursos, como la memoria y las conexiones a bases de datos, tambi\xe9n se realiza en esta fase.")),(0,i.yg)("h2",{id:"c-sintaxis-de-anidaci\xf3n"},"C# Sintaxis de anidaci\xf3n"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C#, la sintaxis de anidaci\xf3n se refiere al concepto de colocar una estructura dentro de otra. Esto es com\xfan en varias \xe1reas del lenguaje, y puede implicar anidar bloques de c\xf3digo, declaraciones de clases, bucles, condicionales, y otros elementos. Aqu\xed te explico algunos casos comunes de anidaci\xf3n en C#:")),(0,i.yg)("h4",{id:"anidaci\xf3n-de-bloques-de-c\xf3digo"},"Anidaci\xf3n de bloques de c\xf3digo"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los bloques de c\xf3digo delimitados por llaves {} pueden contener otros bloques de c\xf3digo, como en los bucles o condicionales:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'if (x > 0) \n{\n    if (x > 10) \n    {\n        Console.WriteLine("x es mayor que 10");\n    }\n    else \n    {\n        Console.WriteLine("x es mayor que 0 pero menor o igual a 10");\n    }\n}\n\n')),(0,i.yg)("h4",{id:"anidaci\xf3n-de-bucles"},"Anidaci\xf3n de bucles"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los bucles pueden estar dentro de otros bucles. Esto es \xfatil cuando trabajas con estructuras complejas como matrices bidimensionales:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'for (int i = 0; i < 5; i++) \n{\n    for (int j = 0; j < 5; j++) \n    {\n        Console.WriteLine($"i: {i}, j: {j}");\n    }\n}\n\n')),(0,i.yg)("h4",{id:"anidaci\xf3n-de-clases"},"Anidaci\xf3n de clases"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C#, puedes declarar una clase dentro de otra clase. Esto se conoce como clases anidadas:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'class ClaseExterna\n{\n    public class ClaseAnidada\n    {\n        public void MetodoAnidado()\n        {\n            Console.WriteLine("M\xe9todo en la clase anidada");\n        }\n    }\n}\n\n// Uso de la clase anidada desde fuera de la clase externa\nClaseExterna.ClaseAnidada instancia = new ClaseExterna.ClaseAnidada();\ninstancia.MetodoAnidado();\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Clases anidadas: \xbfsolo se pueden usar en la clase externa?")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"No necesariamente. Una clase anidada puede ser p\xfablica, privada, o tener cualquier otro modificador de acceso. Dependiendo de ese modificador, la clase anidada podr\xe1 ser utilizada solo dentro de la clase externa o tambi\xe9n fuera de ella.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Si la clase anidada es privada, solo puede ser usada dentro de la clase contenedora."),(0,i.yg)("li",{parentName:"ul"},"Si la clase anidada es p\xfablica o interna, puede ser utilizada desde fuera de la clase externa.")))))),(0,i.yg)("h4",{id:"anidaci\xf3n-de-funciones-locales"},"Anidaci\xf3n de funciones locales"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A partir de C# 7.0, es posible definir funciones locales dentro de otras funciones:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'void MetodoExterno() \n{\n    Console.WriteLine("M\xe9todo externo");\n\n    void MetodoAnidado() \n    {\n        Console.WriteLine("M\xe9todo anidado");\n    }\n\n    MetodoAnidado();\n}\n\n')),(0,i.yg)("h4",{id:"anidaci\xf3n-de-expresiones"},"Anidaci\xf3n de expresiones"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"C# permite anidar expresiones lambda, lo que es \xfatil para realizar c\xe1lculos complejos o trabajar con funciones de orden superior:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"int resultado = (5 + 2) * (3 - 1);\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("p",{parentName:"div"},"En este caso, las expresiones dentro de los par\xe9ntesis est\xe1n anidadas dentro de una operaci\xf3n m\xe1s grande."))),(0,i.yg)("h4",{id:"anidaci\xf3n-de-expresiones-1"},"Anidaci\xf3n de expresiones"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Las expresiones pueden contener otras expresiones, como en el caso de las operaciones matem\xe1ticas complejas o las expresiones lambda:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"Func<int, Func<int, int>> anidada = x => y => x + y;\nConsole.WriteLine(anidada(3)(4)); // Resultado: 7\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("p",{parentName:"div"},"Aqu\xed, la expresi\xf3n lambda que toma y est\xe1 anidada dentro de la que toma x."))),(0,i.yg)("h2",{id:"llaves-en-patr\xf3n-de-coincidencia"},"Llaves en patr\xf3n de coincidencia"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Las llaves ",(0,i.yg)("inlineCode",{parentName:"li"},"{}")," en C# cuando se usan en patrones de coincidencia (pattern matching), tienen un prop\xf3sito espec\xedfico: indican que est\xe1s trabajando con objetos compuestos (objetos que tienen propiedades que pueden contener otro objeto), y te permiten verificar o coincidir con el valor de una o varias de esas propiedades."),(0,i.yg)("li",{parentName:"ul"},"Funci\xf3n de las llaves ",(0,i.yg)("inlineCode",{parentName:"li"},"{}")," en el contexto de patrones de coincidencia:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Acceso a propiedades de un objeto: Las llaves {} permiten desestructurar un objeto y verificar valores dentro de sus propiedades."),(0,i.yg)("li",{parentName:"ol"},"Navegaci\xf3n por niveles de anidaci\xf3n: Las llaves tambi\xe9n son \xfatiles cuando est\xe1s trabajando con objetos que tienen propiedades anidadas, permiti\xe9ndote navegar por ellas.")))),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Desestructurar un objeto ")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"La desestructuraci\xf3n  se refiere a la t\xe9cnica de acceder a las propiedades de un objeto de forma que puedas extraer directamente los valores que necesitas."),(0,i.yg)("li",{parentName:"ul"},"Desestructurar un objeto es como abrir un libro para leer informaci\xf3n espec\xedfica sin tener que pasar p\xe1gina por p\xe1gina. ")))),(0,i.yg)("h4",{id:"ejemplo-con-llaves"},"Ejemplo con llaves"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Supongamos que tienes una clase Persona con una propiedad subtipo y subtipo tiene una propiedad Edad:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"class Subtipo\n{\n    public int Edad { get; set; }\n}\n\nclass Persona\n{\n    public Subtipo subtipo { get; set; }\n}\n\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Y ahora usas el patr\xf3n de coincidencia:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'string resultado = persona switch\n{\n    { subtipo: { Edad: >= 18 } } => "es mayor de edad",\n    _ => "es menor de edad"\n};\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\xbfQu\xe9 hacen las llaves {} aqu\xed?")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"{ subtipo: { Edad: >= 18 } }"),":",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Primera llave ",(0,i.yg)("inlineCode",{parentName:"li"},"{}"),": Est\xe1 desestructurando el objeto persona para acceder a su propiedad subtipo."),(0,i.yg)("li",{parentName:"ul"},"Segunda llave  ",(0,i.yg)("inlineCode",{parentName:"li"},"{}"),": A su vez, est\xe1 desestructurando el objeto subtipo para acceder a su propiedad Edad."))),(0,i.yg)("li",{parentName:"ul"},"En t\xe9rminos simples, las llaves ",(0,i.yg)("inlineCode",{parentName:"li"},"{}"),' permiten navegar por los objetos y sus propiedades internas. Son una manera de decir: "voy a abrir este objeto y voy a mirar dentro de \xe9l".'),(0,i.yg)("li",{parentName:"ul"},"Desglose de este c\xf3digo ",(0,i.yg)("inlineCode",{parentName:"li"},"{ subtipo: { Edad: >= 18 } }"),":",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Primera llave ",(0,i.yg)("inlineCode",{parentName:"li"},"{}"),": Le dice al compilador que busque una propiedad llamada subtipo en el objeto persona."),(0,i.yg)("li",{parentName:"ul"},"Segunda llave ",(0,i.yg)("inlineCode",{parentName:"li"},"{}"),": Dentro de subtipo, le dice que busque la propiedad Edad."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},">= 18"),": Luego, se verifica si la propiedad Edad tiene un valor mayor o igual a 18.")))))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Lo que hicimos anteriormente lo podemos hacer de la siguiente manera con menos c\xf3digo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'string resultado = persona switch\n{\n    { subtipo.Edad: >= 18 } => "es mayor de edad",\n    _ => "es menor de edad"\n};\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este caso estamos usando el ",(0,i.yg)("inlineCode",{parentName:"li"},"\u201cpunto\u201d")," para acceder a una propiedad en lugar de ",(0,i.yg)("inlineCode",{parentName:"li"},"\u201c{}\u201d"),".")))),(0,i.yg)("h2",{id:"heap-y-stack"},"Heap y Stack"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El Heap y el Stack son dos \xe1reas importantes de la memoria en las que un programa almacena datos mientras se ejecuta. Estas \xe1reas son gestionadas de manera diferente y tienen distintas propiedades que influyen en el rendimiento y en la manera en que se manejan las variables en un programa.")),(0,i.yg)("h4",{id:"stack-pila-de-memoria"},"Stack (Pila de memoria)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Stack o pila de memoria es un \xe1rea de memoria usada para almacenar variables locales y datos temporales que se crean y destruyen dentro de una funci\xf3n o m\xe9todo. Esta memoria sigue un modelo de LIFO (Last In, First Out), es decir, el \xfaltimo valor que entra en la pila es el primero en salir.")),(0,i.yg)("h5",{id:"caracter\xedsticas-del-stack"},"Caracter\xedsticas del Stack"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Tama\xf1o limitado: La pila tiene un tama\xf1o fijo, generalmente mucho m\xe1s peque\xf1o que el heap."),(0,i.yg)("li",{parentName:"ul"},"Almacenamiento r\xe1pido: Como la pila sigue un modelo LIFO, la memoria se gestiona de manera muy eficiente. Las operaciones de asignaci\xf3n y liberaci\xf3n de memoria en el stack son r\xe1pidas, porque solo es necesario ajustar un puntero que indica la parte superior de la pila."),(0,i.yg)("li",{parentName:"ul"},"Tipos almacenados: En el stack se almacenan tipos por valor, como los primitivos (int, float, char) y structs en C#. Tambi\xe9n se almacenan referencias a objetos (que se encuentran en el heap)."),(0,i.yg)("li",{parentName:"ul"},"Alcance de las variables: Las variables almacenadas en el stack son locales a la funci\xf3n en la que se declararon, y se destruyen autom\xe1ticamente cuando la funci\xf3n termina. Esto se conoce como vida limitada.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Explicaci\xf3n no t\xe9cnica - La bandeja de platos ")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Imagina que tienes una bandeja donde apilas platos uno encima del otro. Cada vez que necesitas usar un plato, tomas el que est\xe1 en la parte superior de la pila, y cuando terminas de lavarlo, lo colocas de nuevo en la parte superior. Es un sistema muy organizado y r\xe1pido porque siempre sabes d\xf3nde est\xe1n los platos: el \xfaltimo que usaste es el primero en salir, y el primero en entrar es el \xfaltimo en salir."),(0,i.yg)("li",{parentName:"ul"},"Este es el Stack en tu programa:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Es r\xe1pido porque todo sigue un orden."),(0,i.yg)("li",{parentName:"ul"},"Se utiliza para tareas r\xe1pidas y sencillas, como guardar cosas que solo necesitas por un rato (por ejemplo, n\xfameros o variables temporales)."),(0,i.yg)("li",{parentName:"ul"},'Cuando terminas con una tarea, "quitas" los datos (como quitar un plato de la pila), y no hay desorden.')))))),(0,i.yg)("h5",{id:"ejemplo-de-uso-del-stack"},"Ejemplo de uso del Stack"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando declaras una variable local dentro de una funci\xf3n, se asigna espacio para esa variable en el stack, y cuando la funci\xf3n termina, ese espacio se libera autom\xe1ticamente:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"void MiFuncion()\n{\n    int x = 10; // 'x' se almacena en el stack\n    int y = 20; // 'y' tambi\xe9n en el stack\n    // Cuando MiFuncion termina, 'x' y 'y' se eliminan del stack\n}\n\n\n")),(0,i.yg)("h4",{id:"heap-mont\xf3n-de-memora"},"Heap (Mont\xf3n de memora)"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"El Heap o mont\xf3n de memoria es una \xe1rea m\xe1s grande y flexible de memoria utilizada para almacenar objetos y datos din\xe1micos que no se conocen hasta tiempo de ejecuci\xf3n o que tienen una vida m\xe1s prolongada. Es m\xe1s lenta para asignar y liberar memoria en comparaci\xf3n con el stack, pero es m\xe1s flexible.")),(0,i.yg)("h5",{id:"caracter\xedsticas-del-heap"},"Caracter\xedsticas del Heap"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Tama\xf1o grande: El heap suele ser mucho m\xe1s grande que el stack y tiene un tama\xf1o din\xe1mico, es decir, puedes pedir memoria en tiempo de ejecuci\xf3n (por ejemplo, cuando usas new para crear objetos)."),(0,i.yg)("li",{parentName:"ul"},"Almacenamiento m\xe1s lento: La asignaci\xf3n y liberaci\xf3n de memoria en el heap es m\xe1s compleja y m\xe1s lenta. Cuando pides espacio en el heap (por ejemplo, al crear un objeto con new), el sistema tiene que buscar en el heap un lugar donde quepa ese objeto. Esta b\xfasqueda puede tardar un poco porque la memoria en el heap puede estar dividida en varios fragmentos."),(0,i.yg)("li",{parentName:"ul"},"Tipos almacenados: En el heap se almacenan los tipos por referencia, como los objetos y arrays. Estos objetos son accedidos mediante referencias, que se almacenan en el stack."),(0,i.yg)("li",{parentName:"ul"},"Gesti\xf3n de memoria: En C#, la memoria en el heap se gestiona autom\xe1ticamente mediante el Garbage Collector (GC). El GC libera la memoria en el heap cuando detecta que no hay m\xe1s referencias a un objeto. Esto evita fugas de memoria, pero el proceso de recolecci\xf3n puede causar peque\xf1as pausas en el rendimiento.")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Explicaci\xf3n no t\xe9cnica - El estante desorganizado")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Ahora, imagina que tienes un gran estante lleno de cosas, pero no est\xe1 tan organizado. En este estante, guardas cosas m\xe1s grandes o que usar\xe1s por m\xe1s tiempo, como libros, cajas, o incluso m\xe1s platos. El problema es que cuando necesitas poner algo nuevo, tienes que buscar un espacio libre en el estante, y eso puede llevar tiempo. Adem\xe1s, a veces sacas algo, pero el espacio que queda no siempre es \xfatil para lo pr\xf3ximo que quieres guardar, as\xed que el estante se vuelve un poco desordenado."),(0,i.yg)("li",{parentName:"ul"},"Este es el Heap en tu programa:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Es m\xe1s grande que el stack y tiene m\xe1s espacio, pero es m\xe1s lento porque cada vez que necesitas guardar algo, debes buscar un lugar libre."),(0,i.yg)("li",{parentName:"ul"},"Se usa para almacenar cosas que pueden durar m\xe1s tiempo, como objetos grandes (por ejemplo, cuando creas un personaje en un videojuego)."),(0,i.yg)("li",{parentName:"ul"},"Puede desordenarse con el tiempo, y el sistema tiene que organizarlo de vez en cuando (como cuando necesitas reorganizar el estante).")))))),(0,i.yg)("h5",{id:"ejemplo-de-uso-del-heap"},"Ejemplo de uso del Heap"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Cuando creas un objeto usando new, este se almacena en el heap, pero la referencia a ese objeto se almacena en el stack:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"class Persona\n{\n    public string Nombre;\n}\n\nvoid MiFuncion()\n{\n    Persona p = new Persona(); // 'p' es una referencia que est\xe1 en el stack, pero el objeto Persona est\xe1 en el heap\n    p.Nombre = \"Juan\";\n    // El objeto Persona persiste en el heap hasta que el Garbage Collector lo recoja\n}\n\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este caso, la referencia p se almacena en el stack, pero el objeto real (que contiene el campo Nombre) se almacena en el heap. Cuando MiFuncion termine, la referencia p se eliminar\xe1 del stack, pero el objeto en el heap persistir\xe1 hasta que el Garbage Collector lo limpie.")))),(0,i.yg)("h4",{id:"comparaci\xf3n-entre-stack-y-heap"},"Comparaci\xf3n entre Stack y Heap"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Caracter\xedstica"),(0,i.yg)("th",{parentName:"tr",align:null},"Stack"),(0,i.yg)("th",{parentName:"tr",align:null},"Heap"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Tipo de almacenamiento"),(0,i.yg)("td",{parentName:"tr",align:null},"Variables locales, tipos por valor"),(0,i.yg)("td",{parentName:"tr",align:null},"Objetos, arrays, tipos por referencia")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Asignaci\xf3n"),(0,i.yg)("td",{parentName:"tr",align:null},"Autom\xe1tica, r\xe1pida"),(0,i.yg)("td",{parentName:"tr",align:null},"Manual, m\xe1s lenta")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Gesti\xf3n de memoria"),(0,i.yg)("td",{parentName:"tr",align:null},"Autom\xe1tica (se libera al finalizar m\xe9todo)"),(0,i.yg)("td",{parentName:"tr",align:null},"Requiere Garbage Collector")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Tama\xf1o"),(0,i.yg)("td",{parentName:"tr",align:null},"Limitado"),(0,i.yg)("td",{parentName:"tr",align:null},"M\xe1s grande y flexible")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Acceso"),(0,i.yg)("td",{parentName:"tr",align:null},"LIFO (Last In, First Out)"),(0,i.yg)("td",{parentName:"tr",align:null},"No sigue un orden estricto")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Persistencia"),(0,i.yg)("td",{parentName:"tr",align:null},"Vida limitada a la funci\xf3n o m\xe9todo"),(0,i.yg)("td",{parentName:"tr",align:null},"Persiste hasta que el GC lo elimina")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Rendimiento"),(0,i.yg)("td",{parentName:"tr",align:null},"Muy r\xe1pido"),(0,i.yg)("td",{parentName:"tr",align:null},"M\xe1s lento comparado con el stack")))),(0,i.yg)("h4",{id:"ejemplo-pr\xe1ctico-combinando-stack-y-heap"},"Ejemplo pr\xe1ctico combinando Stack y Heap"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Imagina que tienes un programa en el que est\xe1s manejando tanto tipos por valor (como int) y tipos por referencia (como objetos). Aqu\xed se puede ver c\xf3mo se asigna la memoria en el stack y el heap:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},"struct Punto\n{\n    public int X;\n    public int Y;\n}\n\nclass Circulo\n{\n    public int Radio;\n    public Punto Centro; // struct almacenado dentro de la clase\n}\n\nvoid Main()\n{\n    // Variables locales almacenadas en el stack\n    int numero = 42;\n\n    // Struct almacenado en el stack\n    Punto p = new Punto();\n    p.X = 10;\n    p.Y = 20;\n\n    // Clase almacenada en el heap, pero la referencia est\xe1 en el stack\n    Circulo c = new Circulo();\n    c.Radio = 5;\n    c.Centro = p;  // El struct 'Punto' es parte de la clase, pero sigue estando en el heap porque est\xe1 dentro del objeto Circulo\n\n    Console.WriteLine(c.Centro.X); // Acceso a los datos en el heap\n}\n\n\n\n")),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"numero se almacena en el stack porque es un tipo por valor (int)."),(0,i.yg)("li",{parentName:"ul"},"p (de tipo Punto) es un struct y, por lo tanto, tambi\xe9n se almacena en el stack."),(0,i.yg)("li",{parentName:"ul"},"c (de tipo Circulo) es un objeto y, aunque la referencia se almacena en el stack, el objeto completo (incluyendo el struct Punto) se almacena en el heap.")))),(0,i.yg)("h2",{id:"par\xe1metros-posicionales"},"Par\xe1metros posicionales"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los par\xe1metros posicionales son aquellos que se pasan a un m\xe9todo o constructor en un orden espec\xedfico. En C#, cuando defines un m\xe9todo o constructor, puedes especificar una serie de par\xe1metros que el llamador debe proporcionar. La posici\xf3n de cada argumento que pasas es crucial, ya que se asocia con los par\xe1metros definidos en la misma secuencia."),(0,i.yg)("li",{parentName:"ul"},"Los par\xe1metros posicionales en C# son aquellos que se pasan a m\xe9todos o constructores en un orden espec\xedfico. Este enfoque es sencillo y eficiente, pero puede llevar a confusiones si hay muchos par\xe1metros o si se cambian con frecuencia. Para aumentar la claridad, especialmente con m\xe9todos que tienen muchos par\xe1metros, tambi\xe9n puedes usar par\xe1metros nombrados o par\xe1metros opcionales, que permiten especificar el nombre del par\xe1metro al llamarlo, lo que mejora la legibilidad."),(0,i.yg)("li",{parentName:"ul"},"Imagina que tienes un m\xe9todo que calcula el \xe1rea de un rect\xe1ngulo. Para este m\xe9todo, necesitas proporcionar dos par\xe1metros: la anchura y la altura:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Geometria\n{\n    public static double CalcularArea(double ancho, double alto)\n    {\n        return ancho * alto; // Calcula el \xe1rea\n    }\n}\n\nclass Programa\n{\n    static void Main()\n    {\n        // Llamada al m\xe9todo con par\xe1metros posicionales\n        double area = Geometria.CalcularArea(5.0, 10.0); // 5.0 es el ancho, 10.0 es el alto\n        Console.WriteLine("El \xe1rea del rect\xe1ngulo es: " + area);\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"En este ejemplo:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"El m\xe9todo CalcularArea tiene dos par\xe1metros: ancho y alto."),(0,i.yg)("li",{parentName:"ul"},"Cuando llamas a CalcularArea, debes pasar dos valores: primero el ancho (5.0) y luego el alto (10.0)."),(0,i.yg)("li",{parentName:"ul"},"La posici\xf3n es importante: si cambiaras el orden de los argumentos, los resultados ser\xedan incorrectos.")))))),(0,i.yg)("h4",{id:"record"},"Record"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En C# puedes declarar un record utilizando par\xe1metros posicionales. Los records son una caracter\xedstica introducida en C# 9.0 que proporcionan una forma concisa y eficiente de crear tipos de datos inmutables. Permiten definir clases que se centran en la inmutabilidad y la comparaci\xf3n de valores, en lugar de la comparaci\xf3n de referencias, como se hace con las clases regulares."),(0,i.yg)("li",{parentName:"ul"},"Cuando declaras un record utilizando par\xe1metros posicionales, lo haces de manera m\xe1s concisa y clara. Aqu\xed tienes un ejemplo:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public record Person(string FirstName, string LastName); // Declaraci\xf3n de un record con par\xe1metros posicionales\n\nclass Programa\n{\n    static void Main()\n    {\n        // Creaci\xf3n de una instancia del record Person\n        Person persona = new Person("Juan", "P\xe9rez");\n\n        // Mostrando la informaci\xf3n de la persona\n        Console.WriteLine($"Nombre: {persona.FirstName}, Apellido: {persona.LastName}");\n    }\n}\n\n\n')),(0,i.yg)("h2",{id:"parametros-con-nombres"},"Parametros con nombres"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Los par\xe1metros con nombre en C# te permiten pasar argumentos a m\xe9todos y constructores utilizando el nombre del par\xe1metro. Esto mejora la legibilidad y la claridad del c\xf3digo, especialmente en situaciones con m\xfaltiples par\xe1metros. Adem\xe1s, combinados con par\xe1metros opcionales, brindan mayor flexibilidad en la forma en que puedes crear instancias de clases y llamar a m\xe9todos."),(0,i.yg)("li",{parentName:"ul"},"Cuando llamas a un m\xe9todo o un constructor, puedes pasar los par\xe1metros utilizando su nombre en lugar de seguir estrictamente el orden en que se definen. Esto te permite pasar solo aquellos par\xe1metros que deseas, sin necesidad de especificar todos los anteriores."),(0,i.yg)("li",{parentName:"ul"},"Aqu\xed tienes un ejemplo de c\xf3mo funcionan:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Rectangulo\n{\n    public double Ancho { get; }\n    public double Alto { get; }\n\n    // Constructor con par\xe1metros\n    public Rectangulo(double ancho, double alto)\n    {\n        Ancho = ancho;\n        Alto = alto;\n    }\n\n    public double CalcularArea()\n    {\n        return Ancho * Alto;\n    }\n}\n\nclass Programa\n{\n    static void Main()\n    {\n        // Llamada al constructor usando par\xe1metros con nombre\n        Rectangulo rect = new Rectangulo(ancho: 5.0, alto: 10.0);\n\n        // Mostrando el \xe1rea del rect\xe1ngulo\n        Console.WriteLine("El \xe1rea del rect\xe1ngulo es: " + rect.CalcularArea());\n    }\n}\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Definici\xf3n del Constructor:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"En la clase Rectangulo, el constructor Rectangulo(double ancho, double alto) recibe dos par\xe1metros."))),(0,i.yg)("li",{parentName:"ul"},"Uso de Par\xe1metros con Nombre:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Al crear una nueva instancia de Rectangulo, utilizamos ancho: 5.0 y alto: 10.0 para especificar los argumentos. Esto hace que sea claro cu\xe1l es el valor de cada par\xe1metro."),(0,i.yg)("li",{parentName:"ul"},"Puedes cambiar el orden en que pasas los par\xe1metros. Por ejemplo, podr\xedas escribir new Rectangulo(alto: 10.0, ancho: 5.0); y seguir\xeda funcionando sin problemas.")))))),(0,i.yg)("h4",{id:"ejemplo-con-par\xe1metros-opcionales"},"Ejemplo con Par\xe1metros Opcionales"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"En combinaci\xf3n con los par\xe1metros opcionales, los par\xe1metros con nombre pueden ser a\xfan m\xe1s \xfatiles:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Persona\n{\n    public string Nombre { get; }\n    public int Edad { get; }\n    public string Ciudad { get; }\n\n    // Constructor con par\xe1metros opcionales\n    public Persona(string nombre, int edad = 30, string ciudad = "Desconocida")\n    {\n        Nombre = nombre;\n        Edad = edad;\n        Ciudad = ciudad;\n    }\n}\n\nclass Programa\n{\n    static void Main()\n    {\n        // Usando par\xe1metros con nombre y omitiendo los opcionales\n        Persona persona1 = new Persona(nombre: "Juan");\n        Persona persona2 = new Persona(nombre: "Mar\xeda", ciudad: "Madrid");\n\n        Console.WriteLine($"Nombre: {persona1.Nombre}, Edad: {persona1.Edad}, Ciudad: {persona1.Ciudad}");\n        Console.WriteLine($"Nombre: {persona2.Nombre}, Edad: {persona2.Edad}, Ciudad: {persona2.Ciudad}");\n    }\n}\n\n\n\n')),(0,i.yg)("h2",{id:"palabra-clave-sealed"},"Palabra clave Sealed"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},'La palabra clave sealed se aplica a clases y se utiliza para evitar que otras clases hereden de ella. Es una forma de "sellar" la clase, lo que significa que no puedes crear ninguna clase derivada a partir de una clase sellada.')),(0,i.yg)("h4",{id:"por-qu\xe9-usar-sealed"},"\xbfPor qu\xe9 usar sealed?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Hay varias razones para utilizar sealed en una clase:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Control de Herencia: Puede que desees evitar que alguien herede de tu clase para mantener un comportamiento espec\xedfico. Esto es especialmente importante si tu clase est\xe1 dise\xf1ada para ser utilizada tal como est\xe1, sin modificaci\xf3n."),(0,i.yg)("li",{parentName:"ol"},"Optimizaci\xf3n de Rendimiento: Las clases selladas pueden permitir al compilador realizar optimizaciones, ya que se garantiza que no habr\xe1 subclases que cambien el comportamiento."),(0,i.yg)("li",{parentName:"ol"},"Seguridad: Si tienes una clase que contiene l\xf3gica sensible o que no debe ser alterada, marcarla como sellada puede ayudar a protegerla contra la herencia no deseada.")))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Aqu\xed hay un ejemplo simple de una clase sellada:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public sealed class ClaseSellada\n{\n    public void Metodo()\n    {\n        Console.WriteLine("Este es un m\xe9todo de la clase sellada.");\n    }\n}\n\n// La siguiente l\xednea generar\xeda un error de compilaci\xf3n:\n// public class ClaseDerivada : ClaseSellada\n// {\n// }\n\nclass Programa\n{\n    static void Main()\n    {\n        ClaseSellada objeto = new ClaseSellada();\n        objeto.Metodo();\n    }\n}\n\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Detalles del Ejemplo",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Definici\xf3n de la Clase Sellada: La clase ClaseSellada est\xe1 marcada con la palabra clave sealed, lo que significa que no se puede heredar."),(0,i.yg)("li",{parentName:"ol"},"Intento de Herencia: La l\xednea comentada que intenta declarar ClaseDerivada como una subclase de ClaseSellada generar\xeda un error de compilaci\xf3n, ya que ClaseSellada es sellada."),(0,i.yg)("li",{parentName:"ol"},"Uso de la Clase: En el m\xe9todo Main, se puede crear una instancia de ClaseSellada y llamar a su m\xe9todo sin problemas.")))))),(0,i.yg)("h4",{id:"uso-en-m\xe9todos"},"Uso en M\xe9todos"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La palabra clave sealed tambi\xe9n se puede aplicar a m\xe9todos en clases derivadas. Esto significa que puedes sellar un m\xe9todo en una clase base para que no pueda ser anulado (sobrescrito) en clases derivadas. Para hacerlo, primero debes marcar el m\xe9todo en la clase base como virtual y luego sellarlo en la clase derivada:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-csharp"},'public class ClaseBase\n{\n    public virtual void Metodo()\n    {\n        Console.WriteLine("M\xe9todo de la clase base.");\n    }\n}\n\npublic class ClaseDerivada : ClaseBase\n{\n    public sealed override void Metodo()\n    {\n        Console.WriteLine("M\xe9todo sellado de la clase derivada.");\n    }\n}\n\n// La siguiente l\xednea generar\xeda un error de compilaci\xf3n:\n// public class ClaseSubDerivada : ClaseDerivada\n// {\n//     public override void Metodo()\n//     {\n//         Console.WriteLine("Intento de anular el m\xe9todo sellado.");\n//     }\n// }\n\nclass Programa\n{\n    static void Main()\n    {\n        ClaseDerivada objeto = new ClaseDerivada();\n        objeto.Metodo();\n    }\n}\n\n\n')),(0,i.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n ")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("ul",{parentName:"div"},(0,i.yg)("li",{parentName:"ul"},"Clase Base y M\xe9todo Virtual: ClaseBase tiene un m\xe9todo virtual Metodo que se puede anular en clases derivadas."),(0,i.yg)("li",{parentName:"ul"},"Clase Derivada y M\xe9todo Sellado: ClaseDerivada anula el m\xe9todo y lo marca como sellado con la palabra clave sealed. Esto significa que cualquier clase que intente heredar de ClaseDerivada no podr\xe1 anular este m\xe9todo."),(0,i.yg)("li",{parentName:"ul"},"Intento de Herencia de M\xe9todo: La l\xednea comentada en ClaseSubDerivada intentar\xeda anular el m\xe9todo sellado, lo que generar\xeda un error de compilaci\xf3n.")))))}m.isMDXComponent=!0}}]);