"use strict";(self.webpackChunkdocumentacion=self.webpackChunkdocumentacion||[]).push([[8407],{5680:(e,a,n)=>{n.d(a,{xA:()=>c,yg:()=>g});var i=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,i,r=function(e,a){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var t=i.createContext({}),d=function(e){var a=i.useContext(t),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},c=function(e){var a=d(e.components);return i.createElement(t.Provider,{value:a},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},u=i.forwardRef((function(e,a){var n=e.components,r=e.mdxType,o=e.originalType,t=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(n),u=r,g=m["".concat(t,".").concat(u)]||m[u]||p[u]||o;return n?i.createElement(g,l(l({ref:a},c),{},{components:n})):i.createElement(g,l({ref:a},c))}));function g(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=u;var s={};for(var t in a)hasOwnProperty.call(a,t)&&(s[t]=a[t]);s.originalType=e,s[m]="string"==typeof e?e:r,l[1]=s;for(var d=2;d<o;d++)l[d]=n[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4738:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>t,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(8168),r=(n(6540),n(5680));const o={sidebar_position:15},l="C# 10",s={unversionedId:"C--/C10",id:"C--/C10",title:"C# 10",description:"10",source:"@site/docs/C--/C10.md",sourceDirName:"C--",slug:"/C--/C10",permalink:"/documentacion/docs/C--/C10",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/C--/C10.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"C",previous:{title:"Autenticaci\xf3n JWT y Identity Core",permalink:"/documentacion/docs/C--/Identity"},next:{title:"C# 11",permalink:"/documentacion/docs/C--/C11"}},t={},d=[{value:"Global using",id:"global-using",level:2},{value:"Ejemplo",id:"ejemplo",level:4},{value:"Namespace",id:"namespace",level:2},{value:"Minimal API",id:"minimal-api",level:2},{value:"DateOnly y TimeOnly",id:"dateonly-y-timeonly",level:2},{value:"DateOnly",id:"dateonly",level:4},{value:"TimeOnly",id:"timeonly",level:4},{value:"Lambas",id:"lambas",level:2},{value:"Otras mejoras que se hicieron",id:"otras-mejoras-que-se-hicieron",level:4},{value:"PriorityQueue",id:"priorityqueue",level:2},{value:"\xbfQu\xe9 es una PriorityQueue?",id:"qu\xe9-es-una-priorityqueue",level:4},{value:"Sintaxis de PriorityQueue&lt;TElement, TPriority&gt;",id:"sintaxis-de-priorityqueuetelement-tpriority",level:4},{value:"Principales M\xe9todos de PriorityQueue&lt;TElement, TPriority&gt;",id:"principales-m\xe9todos-de-priorityqueuetelement-tpriority",level:4},{value:"Ejemplo",id:"ejemplo-1",level:4},{value:"Linq",id:"linq",level:2},{value:"MinBy y MaxBy",id:"minby-y-maxby",level:4},{value:"Min y Max",id:"min-y-max",level:4},{value:"Chunk",id:"chunk",level:4},{value:"Ejemplo",id:"ejemplo-2",level:5},{value:"Take()",id:"take",level:4},{value:"Ejemplo",id:"ejemplo-3",level:5},{value:"Property patterns",id:"property-patterns",level:2},{value:"Tambi\xe9n en C# 10 se facilita el acceso a las propiedades anidadas.",id:"tambi\xe9n-en-c-10-se-facilita-el-acceso-a-las-propiedades-anidadas",level:4},{value:"Diferencias",id:"diferencias",level:5},{value:"Sintaxis de Patr\xf3n",id:"sintaxis-de-patr\xf3n",level:5},{value:"Legibilidad",id:"legibilidad",level:5},{value:"Mejoras en el patr\xf3n is",id:"mejoras-en-el-patr\xf3n-is",level:4},{value:"Mejoras en los r\xe9cords",id:"mejoras-en-los-r\xe9cords",level:2},{value:"String Interpolaci\xf3n",id:"string-interpolaci\xf3n",level:2},{value:"Structs",id:"structs",level:2},{value:"Mejoras en la expresion \u201cwith\u201d",id:"mejoras-en-la-expresion-with",level:2},{value:"Nullable referencia",id:"nullable-referencia",level:2},{value:"Generic Math",id:"generic-math",level:2},{value:"Caracter\xedsticas clave de Generic Math en C# 10",id:"caracter\xedsticas-clave-de-generic-math-en-c-10",level:4},{value:"Ejemplo de uso",id:"ejemplo-de-uso",level:4},{value:"Beneficios de Generic Math",id:"beneficios-de-generic-math",level:4},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2}],c={toc:d},m="wrapper";function p(e){let{components:a,...n}=e;return(0,r.yg)(m,(0,i.A)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"c-10"},"C# 10"),(0,r.yg)("h2",{id:"global-using"},"Global using"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Las directivas using ahora pueden declararse de manera global para todo el proyecto. En lugar de repetir los using en cada archivo, puedes declararlos una vez y aplicarlos a todo el proyecto."),(0,r.yg)("li",{parentName:"ul"},"No es necesario que las directivas global using se declaren en un archivo espec\xedfico ni en un orden particular. El compilador de C# las procesar\xe1 antes de compilar cualquier otro archivo de c\xf3digo en el proyecto. Puedes colocarlas en cualquier archivo, pero lo m\xe1s com\xfan es crear un archivo llamado GlobalUsings.cs en la ra\xedz del proyecto o en una carpeta de configuraci\xf3n."),(0,r.yg)("li",{parentName:"ul"},"C# 10 reconoce cualquier using precedido por la palabra clave global como una directiva que se aplicar\xe1 a todos los archivos de c\xf3digo dentro del mismo proyecto.")),(0,r.yg)("h4",{id:"ejemplo"},"Ejemplo"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"// En un archivo espec\xedfico, por ejemplo GlobalUsings.cs\nglobal using System;\nglobal using System.Collections.Generic;\n\n")),(0,r.yg)("h2",{id:"namespace"},"Namespace"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 10 introduce una forma m\xe1s concisa de declarar espacios de nombres para evitar la necesidad de abrir y cerrar llaves en torno al c\xf3digo del archivo. El c\xf3digo en ese archivo queda autom\xe1ticamente dentro del espacio de nombres."),(0,r.yg)("li",{parentName:"ul"},"Ejemplo tradicional:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"namespace MyNamespace {\n    public class MyClass {\n        // c\xf3digo\n    }\n}\n\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con file-scoped namespaces:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"namespace MyNamespace;\n\npublic class MyClass {\n    // c\xf3digo\n}\n\n")),(0,r.yg)("h2",{id:"minimal-api"},"Minimal API"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Gracias a C# 10, el c\xf3digo para crear Minimal APIs es m\xe1s corto y m\xe1s limpio. "),(0,r.yg)("li",{parentName:"ul"},"Antes de C# 10, una Minimal API en ASP.NET Core podr\xeda verse as\xed:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// A\xf1adir servicios necesarios\nbuilder.Services.AddEndpointsApiExplorer();\n\nvar app = builder.Build();\n\n// Definir rutas\napp.MapGet("/hello", () => "Hello, World!");\napp.MapGet("/goodbye", () => "Goodbye, World!");\n\n// Iniciar la aplicaci\xf3n\napp.Run();\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con C# 10, puedes utilizar global using directives y file-scoped namespaces, lo que reduce el c\xf3digo de la siguiente manera:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp",metastring:'title="GlobalUsings.cs"',title:'"GlobalUsings.cs"'},"// GlobalUsings.cs\nglobal using Microsoft.AspNetCore.Builder;\nglobal using Microsoft.Extensions.DependencyInjection;\n\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Program.cs"',title:'"Program.cs"'},'namespace MyMinimalApi; // Uso de file-scoped namespace\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// A\xf1adir servicios necesarios\nbuilder.Services.AddEndpointsApiExplorer();\n\nvar app = builder.Build();\n\n// Definir rutas\napp.MapGet("/hello", () => "Hello, World!");\napp.MapGet("/goodbye", () => "Goodbye, World!");\n\n// Iniciar la aplicaci\xf3n\napp.Run();\n\n\n')),(0,r.yg)("h2",{id:"dateonly-y-timeonly"},"DateOnly y TimeOnly"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"DateOnly y TimeOnly son dos tipos de datos introducidos en C# 10 que permiten trabajar con fechas y horas de manera m\xe1s espec\xedfica y eficiente. Estos nuevos tipos abordan algunas de las limitaciones de las clases existentes en .NET, como DateTime.")),(0,r.yg)("h4",{id:"dateonly"},"DateOnly"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Representa una fecha sin una hora asociada. Es \xfatil cuando solo necesitas trabajar con la parte de la fecha, como d\xedas, meses y a\xf1os, sin preocuparte por la parte del tiempo."),(0,r.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"DateOnly date = new DateOnly(2024, 9, 26); // 26 de septiembre de 2024\nConsole.WriteLine(date); // Salida: 2024-09-26\n\n")),(0,r.yg)("h4",{id:"timeonly"},"TimeOnly"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Representa una hora del d\xeda sin una fecha asociada. Es \xfatil cuando solo necesitas trabajar con el tiempo, como horas y minutos."),(0,r.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"TimeOnly time = new TimeOnly(14, 30); // 2:30 PM\nConsole.WriteLine(time); // Salida: 14:30:00\n\n")),(0,r.yg)("h2",{id:"lambas"},"Lambas"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"A partir de C# 10, puedes asignar expresiones lambda directamente a variables con var, sin necesidad de especificar el tipo exacto del delegado (como Func","<","T> o Action","<","T>). Esta es una mejora en la inferencia de tipos del compilador."),(0,r.yg)("li",{parentName:"ul"},"Antes del C# 10:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"Func<int, int> square = x => x * x;\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C#10:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var square = (int x) => x * x; // C# 10 permite esto\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"El compilador infiere que square es un Func","<","int, int>, pero no necesitas especificarlo expl\xedcitamente.")))),(0,r.yg)("h4",{id:"otras-mejoras-que-se-hicieron"},"Otras mejoras que se hicieron"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Antes, cuando se utilizaban expresiones lambda, el compilador infer\xeda autom\xe1ticamente el tipo de retorno. Sin embargo, ahora puedes especificar expl\xedcitamente el tipo de retorno de una expresi\xf3n lambda, lo que mejora la claridad del c\xf3digo, especialmente en contextos donde la inferencia de tipos puede ser confusa:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"Func<int, int> square = (int x) => x * x; // Tipo de retorno expl\xedcito\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Cuando una expresi\xf3n lambda tiene solo un par\xe1metro, puedes omitir los par\xe9ntesis alrededor del par\xe1metro. Esto mejora la legibilidad y hace que el c\xf3digo sea m\xe1s limpio:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"// Sin par\xe9ntesis\nFunc<int, int> doubleValue = x => x * 2;\n\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 10 mejora la inferencia de tipos en expresiones lambda, permitiendo que el compilador sea m\xe1s inteligente al inferir los tipos de los par\xe1metros. Esto significa que puedes omitir la declaraci\xf3n del tipo en muchos casos:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"// El tipo de x es inferido autom\xe1ticamente\nFunc<int, int> increment = x => x + 1;\n\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con C# 10, se pueden usar expresiones interpoladas de forma m\xe1s natural dentro de las lambdas, lo que permite crear cadenas m\xe1s f\xe1cilmente:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var names = new List<string> { "Alice", "Bob", "Charlie" };\nvar greetings = names.Select(name => $"Hello, {name}!");\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"La capacidad de utilizar expresiones lambda con m\xe9todos asincr\xf3nicos tambi\xe9n se ha mejorado. Ahora puedes definir expresiones lambda asincr\xf3nicas m\xe1s f\xe1cilmente y con mejor claridad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'Func<Task<string>> fetchData = async () =>\n{\n    await Task.Delay(1000); // Simula una operaci\xf3n asincr\xf3nica\n    return "Data fetched";\n};\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con C# 10, ahora es m\xe1s f\xe1cil usar lambdas como delegados funcionales, lo que mejora su uso en contextos de programaci\xf3n funcional:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'Action<string> printMessage = message => Console.WriteLine(message);\nprintMessage("Hello, Lambda!");\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"A partir de C#10 se pueden aplicar atributos a las expresiones lambda:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"}," [SomeAttribute]\nFunc<int, int> doble = x => x * 2;\n")),(0,r.yg)("h2",{id:"priorityqueue"},"PriorityQueue"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10 y .NET 6, se introdujo una nueva clase llamada PriorityQueue","<","TElement, TPriority> en el espacio de nombres System.Collections.Generic. Esta colecci\xf3n es una cola de prioridad, que organiza sus elementos de acuerdo con una prioridad asociada, de manera que los elementos con la prioridad m\xe1s alta (o m\xe1s baja, dependiendo de c\xf3mo definas las prioridades) sean los primeros en salir.")),(0,r.yg)("h4",{id:"qu\xe9-es-una-priorityqueue"},"\xbfQu\xe9 es una PriorityQueue?"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Una cola de prioridad es una estructura de datos que permite almacenar elementos junto con sus prioridades, y siempre asegura que el elemento con la prioridad m\xe1s alta (o m\xe1s baja) sea el primero en ser extra\xeddo. A diferencia de una cola tradicional (FIFO), donde los elementos se procesan en el orden en que se insertan, en una PriorityQueue, el orden de salida est\xe1 determinado por las prioridades.")),(0,r.yg)("h4",{id:"sintaxis-de-priorityqueuetelement-tpriority"},"Sintaxis de PriorityQueue","<","TElement, TPriority>"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"TElement: El tipo del elemento que deseas almacenar en la cola."),(0,r.yg)("li",{parentName:"ul"},"TPriority: El tipo de la prioridad que define el orden de los elementos. Este tipo debe implementar IComparable o IComparable","<","T> para poder comparar las prioridades.")),(0,r.yg)("h4",{id:"principales-m\xe9todos-de-priorityqueuetelement-tpriority"},"Principales M\xe9todos de PriorityQueue","<","TElement, TPriority>"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Enqueue(TElement element, TPriority priority): Agrega un elemento a la cola con una prioridad especificada."),(0,r.yg)("li",{parentName:"ol"},"Dequeue(): Elimina y devuelve el elemento con la mayor prioridad."),(0,r.yg)("li",{parentName:"ol"},"Peek(): Devuelve el elemento con la mayor prioridad sin eliminarlo."),(0,r.yg)("li",{parentName:"ol"},"TryDequeue(out TElement element, out TPriority priority): Intenta eliminar el elemento con la mayor prioridad y devuelve true si tiene \xe9xito."),(0,r.yg)("li",{parentName:"ol"},"Count: Devuelve el n\xfamero de elementos en la cola.")),(0,r.yg)("h4",{id:"ejemplo-1"},"Ejemplo"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Aqu\xed te muestro c\xf3mo se puede utilizar PriorityQueue","<","TElement, TPriority> en un ejemplo sencillo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        // Crear una cola de prioridad\n        PriorityQueue<string, int> priorityQueue = new PriorityQueue<string, int>();\n\n        // Encolar elementos con sus prioridades\n        priorityQueue.Enqueue("Tarea urgente", 1);  // Prioridad m\xe1s alta (1 es m\xe1s urgente)\n        priorityQueue.Enqueue("Tarea regular", 3);  // Prioridad m\xe1s baja\n        priorityQueue.Enqueue("Tarea importante", 2);\n\n        // Desencolar y mostrar los elementos seg\xfan sus prioridades\n        while (priorityQueue.Count > 0)\n        {\n            Console.WriteLine(priorityQueue.Dequeue());\n        }\n    }\n}\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Puedes personalizar la comparaci\xf3n de las prioridades si el tipo de prioridad no implementa directamente IComparable, o si deseas cambiar el comportamiento (por ejemplo, hacer que las prioridades m\xe1s altas sean n\xfameros m\xe1s grandes en lugar de m\xe1s peque\xf1os). Para esto, puedes implementar tu propia l\xf3gica de comparaci\xf3n."),(0,r.yg)("li",{parentName:"ul"},"Supongamos que queremos una cola en la que las prioridades m\xe1s altas sean los n\xfameros m\xe1s grandes:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        // Crear una cola de prioridad invertida (donde las prioridades m\xe1s grandes son m\xe1s importantes)\n        PriorityQueue<string, int> priorityQueue = new PriorityQueue<string, int>(Comparer<int>.Create((x, y) => y.CompareTo(x)));\n\n        // Encolar elementos con sus prioridades\n        priorityQueue.Enqueue("Tarea baja", 1);   // Prioridad baja\n        priorityQueue.Enqueue("Tarea alta", 3);   // Prioridad alta\n        priorityQueue.Enqueue("Tarea media", 2);  // Prioridad media\n\n        // Desencolar los elementos en orden de prioridad inversa\n        while (priorityQueue.Count > 0)\n        {\n            Console.WriteLine(priorityQueue.Dequeue());\n        }\n    }\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Con el c\xf3digo ",(0,r.yg)("inlineCode",{parentName:"li"},"Comparer<int>.Create((x, y) => y.CompareTo(x))")," estamos creando un comparador personalizado para enteros(int) que ordena los valores en orden descendente. Te invito a investigar m\xe1s sobre el tema!"),(0,r.yg)("li",{parentName:"ul"},"El constructor de PriorityQueue() recibe el comparador que se va a usar para definir el orden de prioridad.")))),(0,r.yg)("h2",{id:"linq"},"Linq"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En .NET 6 (que acompa\xf1a a C# 10), se introdujeron algunos m\xe9todos nuevos en LINQ que facilitan operaciones comunes, como MinBy y MaxBy, adem\xe1s de los ya conocidos Min y Max. Estos m\xe9todos hacen que trabajar con colecciones sea m\xe1s sencillo y eficiente.")),(0,r.yg)("h4",{id:"minby-y-maxby"},"MinBy y MaxBy"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"MinBy y MaxBy son m\xe9todos que te permiten encontrar un elemento de una colecci\xf3n que tenga el valor m\xe1s bajo o m\xe1s alto de una propiedad o campo espec\xedfico que determines. Antes de la introducci\xf3n de estos m\xe9todos, para obtener un objeto completo basado en una propiedad m\xednima o m\xe1xima, necesitabas usar combinaciones de m\xe9todos como OrderBy o Where, lo que hac\xeda el c\xf3digo m\xe1s largo y menos eficiente. Ahora, con MinBy y MaxBy, puedes lograrlo de manera m\xe1s directa y concisa."),(0,r.yg)("li",{parentName:"ul"},"Si quer\xedas encontrar a la persona m\xe1s joven antes de .NET 6, el c\xf3digo se ve\xeda as\xed:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var youngest = people.OrderBy(p => p.Age).First();\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con MinBy, simplemente puedes escribir:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var youngest = people.MinBy(p => p.Age);\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Obtienes a la persona cuya propiedad age tenga el valor m\xe1s bajo.")))),(0,r.yg)("h4",{id:"min-y-max"},"Min y Max"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Los m\xe9todos Min y Max ya exist\xedan antes de C# 10, pero solo funcionaban para valores simples como n\xfameros o tipos comparables. Estos m\xe9todos te permiten obtener el valor m\xednimo o m\xe1ximo directamente de una lista de n\xfameros o valores que implementan la interfaz IComparable.")),(0,r.yg)("h4",{id:"chunk"},"Chunk"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"El m\xe9todo Chunk fue introducido en .NET 6, que acompa\xf1a a C# 10. Este m\xe9todo permite dividir una colecci\xf3n en subconjuntos (chunks) de tama\xf1o fijo, lo cual es \xfatil cuando deseas procesar una lista de elementos en bloques o lotes."),(0,r.yg)("li",{parentName:"ul"},"El m\xe9todo Chunk toma una colecci\xf3n y la divide en grupos de un tama\xf1o determinado. Cada grupo es devuelto como una matriz. Esto es particularmente \xfatil en situaciones en las que necesitas dividir una lista grande en fragmentos m\xe1s manejables.")),(0,r.yg)("h5",{id:"ejemplo-2"},"Ejemplo"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Imagina que tienes una lista de n\xfameros y quieres dividirla en grupos de tres elementos:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var numbers = Enumerable.Range(1, 10);\n\n// Dividir la lista en grupos de 3 elementos\nvar chunks = numbers.Chunk(3);\n\nforeach (var chunk in chunks)\n{\n    Console.WriteLine($"Chunk: {string.Join(", ", chunk)}");\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},'Si la colecci\xf3n no se puede dividir equitativamente, el \xfaltimo chunk contendr\xe1 menos elementos que los anteriores (como en el ejemplo, donde el \xfaltimo "chunk" tiene solo un n\xfamero).'),(0,r.yg)("li",{parentName:"ul"},"Chunk es \xfatil para trabajar con datos en paralelo o para limitar la cantidad de datos procesados en una operaci\xf3n.")))),(0,r.yg)("h4",{id:"take"},"Take()"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"El m\xe9todo Take ya exist\xeda en versiones anteriores de LINQ, pero en .NET 6 (junto con C# 10), se introdujeron algunas mejoras y nuevos m\xe9todos que complementan su funcionalidad. El m\xe9todo Take se utiliza para seleccionar un n\xfamero espec\xedfico de elementos de una colecci\xf3n, lo que es \xfatil para limitar el n\xfamero de resultados devueltos por una consulta."),(0,r.yg)("li",{parentName:"ul"},"El m\xe9todo Take permite obtener los primeros n elementos de una colecci\xf3n. Esto es \xfatil en situaciones donde deseas limitar los resultados, como en paginaci\xf3n o al obtener solo un n\xfamero espec\xedfico de registros.")),(0,r.yg)("h5",{id:"ejemplo-3"},"Ejemplo"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Supongamos que tienes una lista de n\xfameros y deseas obtener solo los primeros tres:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n// Obtener los primeros 3 elementos\nvar firstThree = numbers.Take(3);\n\nforeach (var number in firstThree)\n{\n    Console.WriteLine(number);\n}\n\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10 y .NET 6, se introdujo una forma de trabajar con rangos que permite especificar un rango de elementos al usar m\xe9todos como Take. Esto hace que la manipulaci\xf3n de colecciones sea a\xfan m\xe1s vers\xe1til."),(0,r.yg)("li",{parentName:"ul"},"Con el soporte de rangos en C# 10, puedes utilizar el m\xe9todo Take junto con la sintaxis de rangos para especificar cu\xe1ntos elementos quieres tomar de una colecci\xf3n a partir de un \xedndice espec\xedfico. Esto permite obtener un subconjunto m\xe1s controlado de elementos de una lista."),(0,r.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n        // Usamos Take con un Range para obtener los elementos del \xedndice 2 al 6 (sin incluir el 7)\n        var takenNumbers = numbers.Take(2..7); // Esto tomar\xe1 los n\xfameros 3, 4, 5, 6 (sin incluir el 7)\n\n        Console.WriteLine("Los n\xfameros tomados son:");\n        foreach (var number in takenNumbers)\n        {\n            Console.WriteLine(number); // Se imprimir\xe1n 3, 4, 5, 6\n        }\n    }\n}\n\n')),(0,r.yg)("h2",{id:"property-patterns"},"Property patterns"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Las property patterns son una caracter\xedstica que se introdujo en C# 10 y se basan en el concepto de pattern matching (coincidencia de patrones), que permite verificar la forma de un objeto de una manera m\xe1s expresiva y concisa"),(0,r.yg)("li",{parentName:"ul"},"Los property patterns permiten verificar y descomponer propiedades de un objeto en una sola expresi\xf3n. Esto es especialmente \xfatil en situaciones donde deseas validar o extraer informaci\xf3n de un objeto sin necesidad de escribir m\xfaltiples condiciones."),(0,r.yg)("li",{parentName:"ul"},"La sintaxis b\xe1sica de un property pattern consiste en:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Verificar que un objeto sea de un tipo espec\xedfico."),(0,r.yg)("li",{parentName:"ul"},"Acceder a sus propiedades para comprobar sus valores."))),(0,r.yg)("li",{parentName:"ul"},"Imagina que tienes una clase llamada Persona con propiedades como Nombre y Edad. Aqu\xed hay un ejemplo de c\xf3mo usar property patterns:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\npublic class Persona\n{\n    public string Nombre { get; set; }\n    public int Edad { get; set; }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var persona = new Persona { Nombre = "Juan", Edad = 30 };\n\n        // Usando property pattern para verificar la propiedad\n        if (persona is { Nombre: "Juan", Edad: 30 })\n        {\n            Console.WriteLine("\xa1Hola, Juan! Tienes 30 a\xf1os.");\n        }\n        else\n        {\n            Console.WriteLine("No es Juan o la edad no coincide.");\n        }\n    }\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Desglose del Ejemplo")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Definici\xf3n de la Clase: La clase Persona tiene dos propiedades: Nombre y Edad."),(0,r.yg)("li",{parentName:"ul"},"Instancia de Persona: Creamos una instancia de Persona llamada persona."),(0,r.yg)("li",{parentName:"ul"},'Property Pattern: Usamos la coincidencia de patrones para verificar si persona tiene el nombre "Juan" y la edad 30 en una sola expresi\xf3n:'),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},'if (persona is { Nombre: "Juan", Edad: 30 })'),":",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Esto verifica que persona sea del tipo Persona y que las propiedades Nombre y Edad tengan los valores esperados."),(0,r.yg)("li",{parentName:"ul"},"Resultado: Si ambas condiciones son verdaderas, se imprime un saludo; de lo contrario, se indica que no es Juan o que la edad no coincide.")))))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Tambi\xe9n podemos capturar el valor:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System;\n\npublic class Persona\n{\n    public string Nombre { get; set; }\n    public int Edad { get; set; }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var persona = new Persona { Nombre = "Juan", Edad = 30 };\n\n        // Usando property pattern para validar\n        if (persona is { Nombre: var nombre, Edad: var edad })\n        {\n            // Ahora podemos acceder a \'nombre\' y \'edad\' porque los hemos capturado\n            Console.WriteLine($"\xa1Hola, {nombre}! Tienes {edad} a\xf1os.");\n        }\n        else\n        {\n            Console.WriteLine("No es Juan o la edad no coincide.");\n        }\n    }\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Ahora en el if estamos validando si persona tiene las propiedades Nombre y Edad, y al mismo tiempo capturamos sus valores en las variables nombre y edad."),(0,r.yg)("li",{parentName:"ul"},"Una vez validados, los valores se utilizan para imprimir un mensaje.")))),(0,r.yg)("h4",{id:"tambi\xe9n-en-c-10-se-facilita-el-acceso-a-las-propiedades-anidadas"},"Tambi\xe9n en C# 10 se facilita el acceso a las propiedades anidadas."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 9:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'string resultado = persona switch\n{\n    { subtipo: { Edad: >= 18 } } => "es mayor de edad",\n    _ => "es menor de edad"\n};\n\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'string resultado = persona switch\n{\n    { subtipo.Edad: >= 18 } => "es mayor de edad",\n    _ => "es menor de edad"\n};\n\n')),(0,r.yg)("h5",{id:"diferencias"},"Diferencias"),(0,r.yg)("h5",{id:"sintaxis-de-patr\xf3n"},"Sintaxis de Patr\xf3n"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 9: Utiliza una forma m\xe1s compleja para acceder a las propiedades mediante la sintaxis de anidaci\xf3n ",(0,r.yg)("inlineCode",{parentName:"li"},"({ subtipo: { Edad: >= 18 } })"),". Esto implica que se accede al objeto subtipo (que es una propiedad de persona) y luego se verifica que la propiedad Edad (que es una propiedad de subtipo) sea mayor a 18 en una sola expresi\xf3n de patr\xf3n."),(0,r.yg)("li",{parentName:"ul"},"C# 10: Simplifica la expresi\xf3n utilizando subtipo.Edad: >= 18, permitiendo un acceso m\xe1s directo a la propiedad Edad del objeto subtipo.")),(0,r.yg)("h5",{id:"legibilidad"},"Legibilidad"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 9: La sintaxis m\xe1s anidada puede ser un poco m\xe1s dif\xedcil de leer y entender a primera vista, especialmente para quienes no est\xe1n familiarizados con las expresiones de patr\xf3n complejas."),(0,r.yg)("li",{parentName:"ul"},"C# 10: La sintaxis m\xe1s simple mejora la legibilidad del c\xf3digo, lo que facilita la comprensi\xf3n de las condiciones que se est\xe1n evaluando.")),(0,r.yg)("h4",{id:"mejoras-en-el-patr\xf3n-is"},"Mejoras en el patr\xf3n is"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Se han a\xf1adido mejoras al patr\xf3n is, permitiendo combinaciones m\xe1s complejas y legibilidad:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"if (obj is int number and > 0)\n{\n    // Haz algo con la variable number que es mayor que 0\n}\n\n")),(0,r.yg)("h2",{id:"mejoras-en-los-r\xe9cords"},"Mejoras en los r\xe9cords"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10, los records ya no est\xe1n limitados a clases. Ahora puedes definir records con tipo struct. Esto es \xfatil cuando necesitas las ventajas de un record (inmutabilidad, igualdad basada en valores, etc.), pero quieres evitar la sobrecarga de asignaci\xf3n en el heap que ocurre con las clases."),(0,r.yg)("li",{parentName:"ul"},"Ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public record struct Punto(int X, int Y);\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Con esta mejora, Punto es un record struct, lo que significa que se comporta como un valor, no como una referencia, pero sigue teniendo las caracter\xedsticas de un record, como la igualdad basada en valores.")))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 10 permite mejoras en la herencia de records. En C# 9, los records pod\xedan heredar de otros records, pero hab\xeda limitaciones en la forma en que los constructores y propiedades se comportaban. En C# 10, este mecanismo ha mejorado, permitiendo una experiencia m\xe1s fluida en la herencia y evitando algunos problemas de duplicaci\xf3n de c\xf3digo en los constructores:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public record Persona(string Nombre);\npublic record Empleado(string Nombre, string Cargo) : Persona(Nombre);\n\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("p",{parentName:"div"},"El c\xf3digo define un record llamado Empleado que hereda el record Persona. El record Empleado tiene dos propiedades: Nombre, que es pasado a Persona, y Cargo, que es espec\xedfico de Empleado."))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10, tambi\xe9n puedes usar constructores de tipo record struct con m\xe1s flexibilidad. Esto significa que puedes definir constructores expl\xedcitos para inicializar las propiedades, lo cual antes era m\xe1s restrictivo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public record struct Punto\n{\n    public int X { get; init; }\n    public int Y { get; init; }\n\n    public Punto(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n}\n\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Una novedad introducida en C# 10 es que los records ahora pueden tener el m\xe9todo ToString sellado(sealed) autom\xe1ticamente cuando se declaran como record struct o record class sealed."),(0,r.yg)("li",{parentName:"ul"},"Si declaras un record como sealed, entonces el compilador genera un m\xe9todo ToString sellado autom\xe1ticamente. Esto significa que no se puede sobrescribir m\xe1s abajo en la jerarqu\xeda de herencia. Ejemplo:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public sealed record Empleado(string Nombre);\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"En este caso, el m\xe9todo ToString generado para Empleado estar\xe1 sellado, por lo que no podr\xe1 ser sobrescrito en clases derivadas (aunque no podr\xedas derivar de un record sellado de todas maneras, ya que no es heredable).")))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"record struct: Los record structs tambi\xe9n generan autom\xe1ticamente un m\xe9todo ToString sellado porque las estructuras (structs) en C# no permiten herencia. As\xed que, por definici\xf3n, los m\xe9todos como ToString no se pueden sobrescribir en derivados de un struct:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public record struct Empleado(string Nombre);\n")),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\xbfQu\xe9 significa que ToString est\xe9 sellado?")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Cuando un m\xe9todo est\xe1 sellado (marcado con sealed), no puede ser sobrescrito por clases derivadas. Esto es \xfatil para evitar cambios en la implementaci\xf3n en clases m\xe1s abajo en la jerarqu\xeda de herencia.")))),(0,r.yg)("h2",{id:"string-interpolaci\xf3n"},"String Interpolaci\xf3n"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Con C# 10, se pueden usar las interpolaciones de cadenas en campos const tambi\xe9n. Esto significa que ahora puedes definir un campo const con valores interpolados. Esto era imposible antes, ya que los campos const deben tener valores que se conocen en tiempo de compilaci\xf3n:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public class Persona\n{\n    public const string Nombre = "Juan";\n    public const string Mensaje = $"Hola, {Nombre}";\n}\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"En este caso, Mensaje se puede definir como const utilizando la interpolaci\xf3n de cadenas, ya que Nombre es un valor constante.")))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Se permiten nuevas l\xedneas dentro de cadenas interpoladas, mejorando la legibilidad de los textos largos:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'var message = $"Hello, {name}!\\nWelcome to C# 10.";\n')),(0,r.yg)("h2",{id:"structs"},"Structs"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Se permite que las estructuras tengan constructores sin par\xe1metros, lo que facilita la inicializaci\xf3n:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public struct Punto\n{\n    public int X;\n    public int Y;\n\n    public Punto() // Constructor sin par\xe1metros\n    {\n        X = 0;\n        Y = 0;\n    }\n}\n\n")),(0,r.yg)("h2",{id:"mejoras-en-la-expresion-with"},"Mejoras en la expresion \u201cwith\u201d"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Se hicieron mejoras en la expresi\xf3n with para crear copias de registros."),(0,r.yg)("li",{parentName:"ul"},"En C# 9:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public record Direccion(string Calle, string Ciudad);\npublic record Empleado(string Nombre, int Edad, Direccion Direccion);\n\nvar empleado1 = new Empleado("Juan", 30, new Direccion("Main St", "Ciudad A"));\n\n// Necesitas crear una nueva instancia de Direccion expl\xedcitamente para modificarla\nvar empleado2 = empleado1 with { Direccion = new Direccion("Second St", "Ciudad B") };\n\nConsole.WriteLine(empleado1); // Salida: Empleado { Nombre = Juan, Edad = 30, Direccion = Direccion { Calle = Main St, Ciudad = Ciudad A } }\nConsole.WriteLine(empleado2); // Salida: Empleado { Nombre = Juan, Edad = 30, Direccion = Direccion { Calle = Second St, Ciudad = Ciudad B } }\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Tienes que crear una nueva instancia de Direccion cada vez que quieras modificar la direcci\xf3n. La expresi\xf3n with es utilizada, pero es necesario volver a instanciar el objeto.")))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"En C# 10:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'public record Direccion(string Calle, string Ciudad);\npublic record Empleado(string Nombre, int Edad, Direccion Direccion);\n\n// Inicializaci\xf3n m\xe1s limpia de registros anidados\nvar empleado1 = new Empleado("Juan", 30, new Direccion("Main St", "Ciudad A"));\n\n// Mejor manejo de registros complejos, podr\xedas usar un constructor directo\nvar empleado2 = empleado1 with { Direccion = empleado1.Direccion with { Calle = "Second St" } };\n\nConsole.WriteLine(empleado1); // Salida: Empleado { Nombre = Juan, Edad = 30, Direccion = Direccion { Calle = Main St, Ciudad = Ciudad A } }\nConsole.WriteLine(empleado2); // Salida: Empleado { Nombre = Juan, Edad = 30, Direccion = Direccion { Calle = Second St, Ciudad = Ciudad A } }\n\n\n')),(0,r.yg)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.yg)("div",{parentName:"div",className:"admonition-heading"},(0,r.yg)("h5",{parentName:"div"},(0,r.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,r.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Observaci\xf3n")),(0,r.yg)("div",{parentName:"div",className:"admonition-content"},(0,r.yg)("ul",{parentName:"div"},(0,r.yg)("li",{parentName:"ul"},"Puedes usar la expresi\xf3n with anidada para modificar solo una propiedad de un registro anidado de forma m\xe1s clara. En este caso, ",(0,r.yg)("inlineCode",{parentName:"li"},'empleado1.Direccion with { Calle = "Second St" }')," es una forma m\xe1s elegante de modificar solo la propiedad deseada.")))),(0,r.yg)("h2",{id:"nullable-referencia"},"Nullable referencia"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"A partir del C#10 podemos permitir que una variable sea null:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},"public string? Nombre { get; set; } // Permite que Nombre sea nulo\n")),(0,r.yg)("h2",{id:"generic-math"},"Generic Math"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"C# 10 introdujo una caracter\xedstica conocida como Generic Math (matem\xe1ticas gen\xe9ricas), que permite a los desarrolladores escribir c\xf3digo matem\xe1tico m\xe1s gen\xe9rico y reutilizable para diferentes tipos de datos. Esta caracter\xedstica se basa en el concepto de utilizar interfaces y tipos gen\xe9ricos para definir operaciones matem\xe1ticas que pueden aplicarse a una variedad de tipos num\xe9ricos.")),(0,r.yg)("h4",{id:"caracter\xedsticas-clave-de-generic-math-en-c-10"},"Caracter\xedsticas clave de Generic Math en C# 10"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Interfaces matem\xe1ticas:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Se introdujeron varias interfaces matem\xe1ticas que los tipos num\xe9ricos pueden implementar. Estas interfaces permiten realizar operaciones como suma, resta, multiplicaci\xf3n y divisi\xf3n de manera gen\xe9rica. Algunas de las interfaces relevantes son:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"INumber","<","T>: Representa tipos num\xe9ricos y permite realizar operaciones b\xe1sicas."),(0,r.yg)("li",{parentName:"ul"},"IAdditionOperators","<","TSelf, TOther, TResult>: Define la operaci\xf3n de suma."),(0,r.yg)("li",{parentName:"ul"},"IMultiplicationOperators","<","TSelf, TOther, TResult>: Define la operaci\xf3n de multiplicaci\xf3n."))))),(0,r.yg)("li",{parentName:"ul"},"Tipos num\xe9ricos enriquecidos:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Los tipos num\xe9ricos en .NET, como int, float, double, y decimal, implementan estas interfaces, lo que permite a los desarrolladores usar estas operaciones de forma consistente en diferentes tipos num\xe9ricos."))),(0,r.yg)("li",{parentName:"ul"},"Operaciones matem\xe1ticas gen\xe9ricas:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Con Generic Math, puedes definir m\xe9todos y algoritmos que funcionan con cualquier tipo num\xe9rico que implemente estas interfaces. Esto hace que el c\xf3digo sea m\xe1s flexible y reusable.")))),(0,r.yg)("h4",{id:"ejemplo-de-uso"},"Ejemplo de uso"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csharp"},'using System.Numerics;\n\nclass OperacionesMatematicas\n{\n    public static T Add<T>(T x, T y) where T : INumber<T>\n    {\n        return x + y; // Utiliza la operaci\xf3n de suma definida en INumber\n    }\n}\n\nusing System;\nint a = 5;\nint b = 3;\nint suma = OperacionesMatematicas.Add(a, b);\nConsole.WriteLine($"Suma: {suma}"); // Salida: Suma: 8\n\n\n')),(0,r.yg)("h4",{id:"beneficios-de-generic-math"},"Beneficios de Generic Math"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Reutilizaci\xf3n de c\xf3digo: Puedes escribir funciones y algoritmos que funcionen con diferentes tipos num\xe9ricos sin duplicar el c\xf3digo."),(0,r.yg)("li",{parentName:"ul"},"Consistencia: Las operaciones matem\xe1ticas se aplican de manera coherente a trav\xe9s de diferentes tipos."),(0,r.yg)("li",{parentName:"ul"},"Simplicidad: El uso de interfaces simplifica la implementaci\xf3n de operaciones matem\xe1ticas, lo que hace que el c\xf3digo sea m\xe1s limpio y f\xe1cil de entender.")),(0,r.yg)("h2",{id:"m\xe1s-informaci\xf3n"},(0,r.yg)("a",{parentName:"h2",href:"https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10"},"M\xe1s informaci\xf3n")))}p.isMDXComponent=!0}}]);